{"version":3,"sources":["webpack:///D:/Projects/rick-love-master/code/doodle/doodle.ts","webpack:///D:/Projects/rick-love-master/code/doodle/doodle-view.tsx"],"names":["doodleSegmentToSvgPath_line","segment","points","length","x","y","last","slice","map","p","t","join","styles","drawing","width","height","color","backgroundColor","DoodleTestView","props","useState","segments","doodle","setDoodle","style","onChange","DoodleDrawerView","scale","setSegment","segmentClientStart","useRef","divHost","onIgnore","e","preventDefault","stopPropagation","nativeEvent","cancelBubble","returnValue","onPressIn","event","pos","div","current","rect","getBoundingClientRect","clientX","clientY","Math","floor","onPressOut","s","onClientMove","lastPos","abs","onMove","useEffect","onIgnoreNative","document","addEventListener","passive","removeEventListener","position","viewBox","preserveAspectRatio","xmlns","i","key","d","stroke","fill","ref","left","right","top","bottom","zIndex","onMouseDown","onMouseUp","onMouseMove","onMouseLeave","onTouchStart","touches","onTouchEnd","onTouchCancel","onTouchMove","onTouchEndCapture","DoodleDisplayView"],"mappings":"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","file":"20-321609955d768c058381.js","sourcesContent":["export type DoodleDrawingStorageService = {\r\n    saveDrawing: (prompt: string, drawing: DoodleDrawing) => Promise<void>;\r\n    getDrawings: (prompt: string, options?: { includeOtherPrompts?: boolean, maxCount?: number }) => Promise<{ doodles: DoodleData[] }>;\r\n    saveBestDrawingSelection: (doodle: DoodleData) => Promise<void>;\r\n};\r\n\r\n\r\nexport type DoodleSummaryDataJson = {\r\n    doodles: DoodleData_EncodedWithScore[];\r\n};\r\nexport type DoodleData_EncodedWithScore = DoodleData_Encoded & {\r\n    s: number;\r\n};\r\n\r\nexport type DoodleUserDrawingDataJson = {\r\n    doodles: DoodleData_Encoded[];\r\n};\r\n\r\nexport type DoodleUserVotesDataJson = {\r\n    doodleVotes: DoodleScoreVote[];\r\n};\r\n\r\nexport type DoodleScoreVote = {\r\n    // Doodle Key\r\n    k: string;\r\n    // Doodle Timestamp\r\n    t: number;\r\n};\r\n\r\nexport type DoodleScore = {\r\n    doodleKey: string;\r\n    score: number;\r\n};\r\n\r\nexport type DoodleData = {\r\n    key: string;\r\n    drawing: DoodleDrawing;\r\n    prompt: string;\r\n    timestamp: number;\r\n};\r\nexport type DoodleData_Encoded = {\r\n    // Doodle Key\r\n    k: string;\r\n    // Doodle Drawing\r\n    d: DoodleDrawingEncoded;\r\n    // Prompt\r\n    p: string;\r\n    // Doodle Timestamp\r\n    t: number;\r\n};\r\n\r\nexport type DoodleDrawing = {\r\n    width: number;\r\n    height: number;\r\n    segments: DoodleSegment[];\r\n};\r\nexport type DoodleSegment = {\r\n    points: { x: number, y: number }[];\r\n};\r\n\r\n// const sampleDrawing: DoodleDrawing = {\r\n//     width: 128,\r\n//     height: 128,\r\n//     segments: [{\r\n//         points: [\r\n//             { x: 10, y: 10 },\r\n//             { x: 50, y: 10 },\r\n//             { x: 50, y: 50 },\r\n//             { x: 10, y: 50 },\r\n//             { x: 10, y: 10 },\r\n//         ],\r\n//     }],\r\n// };\r\n\r\nexport const defaultDoodleDrawing = (): DoodleDrawing => ({\r\n    width: 104,\r\n    height: 104,\r\n    segments: [],\r\n});\r\n\r\nexport type DoodleDrawingEncoded = {\r\n    doodleText: string;\r\n};\r\ntype DoodleDrawingEncodedObj = {\r\n    w: number;\r\n    h: number;\r\n    s: {\r\n        x: number;\r\n        y: number;\r\n        p: string;\r\n    }[];\r\n};\r\nconst encodeDoodleSegmentPoints = (points: { x: number, y: number }[]): string => {\r\n    if (points.length <= 0) { return ``; }\r\n    let last = points[0];\r\n    let t = ``;\r\n\r\n    points.slice(1).forEach(p => {\r\n        t += `${p.x - last.x},${p.y - last.y};`;\r\n        last = p;\r\n    });\r\n\r\n    return t;\r\n};\r\nconst decodeDoodleSegmentPoints = (x: number, y: number, pointsString: string): { x: number, y: number }[] => {\r\n    if (!pointsString) { return [{ x, y }]; }\r\n    let last = { x, y };\r\n    const pointRelPos = pointsString.split(`;`).filter(p => p);\r\n    const points = pointRelPos.map(p => {\r\n        const parts = p.split(`,`);\r\n        const point = {\r\n            x: last.x + Number.parseInt(parts[0], 10),\r\n            y: last.y + Number.parseInt(parts[1], 10),\r\n        };\r\n        last = point;\r\n        return point;\r\n    });\r\n\r\n    return [...points];\r\n};\r\n\r\nexport const encodeDoodleDrawing = (doodle: DoodleDrawing): DoodleDrawingEncoded => {\r\n    const o: DoodleDrawingEncodedObj = {\r\n        w: doodle.width,\r\n        h: doodle.height,\r\n        s: doodle.segments.map(x => ({\r\n            x: x.points[0].x,\r\n            y: x.points[0].y,\r\n            p: encodeDoodleSegmentPoints(x.points),\r\n        })),\r\n    };\r\n    return { doodleText: JSON.stringify(o) };\r\n};\r\nexport const decodeDoodleDrawing = (doodle: DoodleDrawingEncoded): DoodleDrawing => {\r\n    const o: DoodleDrawingEncodedObj = JSON.parse(doodle.doodleText) as DoodleDrawingEncodedObj;\r\n    return {\r\n        width: o.w,\r\n        height: o.h,\r\n        segments: o.s.map(p => {\r\n            return {\r\n                points: [{ x: p.x, y: p.y }, ...decodeDoodleSegmentPoints(p.x, p.y, p.p)],\r\n            };\r\n        }),\r\n    };\r\n};\r\n\r\n\r\n// const doodleSegmentToSvgPath_bezier = (segment: DoodleSegment) => {\r\n//     const delta1 = {\r\n//         x: segment.points[2].x - segment.points[1].x,\r\n//         y: segment.points[2].y - segment.points[1].y,\r\n//     };\r\n//     const controlPoint = {\r\n//         x: segment.points[1].x - delta1.x * 0.5,\r\n//         y: segment.points[1].y - delta1.y * 0.5,\r\n//     };\r\n//     return `M${segment.points[0].x} ${segment.points[0].y} Q${controlPoint.x} ${controlPoint.y} ${segment.points[1].x} ${segment.points[1].y}T${segment.points.slice(2, -1).map(p => `${p.x} ${p.y}`).join(` `)}`;\r\n// };\r\n\r\n\r\nexport const doodleSegmentToSvgPath_line = (segment: DoodleSegment) => {\r\n    if (segment.points.length <= 0) { return ``; }\r\n    if (segment.points.length === 1) { return `M${segment.points[0].x} ${segment.points[0].y} L${segment.points[0].x} ${segment.points[0].y}`; }\r\n\r\n    let last = segment.points[0];\r\n    return `M${segment.points[0].x} ${segment.points[0].y} l${segment.points.slice(1).map(p => {\r\n        const t = `${p.x - last.x} ${p.y - last.y}`;\r\n        last = p;\r\n        return t;\r\n    }).join(` `)}`;\r\n};\r\n\r\nexport const doodleToSvg = (drawing: DoodleDrawing) => {\r\n    // preserveAspectRatio='none' stroke='#000000' fill='transparent' xmlns='http://www.w3.org/2000/svg'\r\n    return `\r\n<svg viewBox='0 0 ${drawing.width} ${drawing.height}' stroke='#000000' fill='transparent'>\r\n    ${drawing.segments.map((x, i) => (\r\n        `<path d='${doodleSegmentToSvgPath_line(x)}' />`\r\n    )).join(``)}\r\n</svg>\r\n    `.trim();\r\n};\r\n","/* eslint-disable react/no-array-index-key */\r\n/* eslint-disable jsx-a11y/no-static-element-interactions */\r\nimport React, { useState, useRef, useEffect } from 'react';\r\nimport { defaultDoodleDrawing, DoodleSegment, DoodleDrawing, encodeDoodleDrawing, decodeDoodleDrawing, doodleSegmentToSvgPath_line, doodleToSvg } from './doodle';\r\n\r\nexport const styles = {\r\n    drawing: {\r\n        width: 312,\r\n        height: 312,\r\n        color: `#FFFFFF`,\r\n        backgroundColor: `#000000`,\r\n    },\r\n};\r\n\r\nexport const DoodleTestView = (props: {}) => {\r\n    const [doodle, setDoodle] = useState(defaultDoodleDrawing());\r\n\r\n    return (\r\n        <>\r\n            <DoodleDrawerView style={styles.drawing} drawing={doodle} onChange={setDoodle} />\r\n            <DoodleDisplayView style={styles.drawing} drawing={doodle} />\r\n        </>\r\n    );\r\n};\r\n\r\n// export const DoodleDrawingView = (props: { drawing?: DoodleDrawing, onDrawingChanged: (drawing: DoodleDrawing) => void }) => {\r\n\r\n//     const [doodle, setDoodle] = useState(props.drawing ?? defaultDoodleDrawing());\r\n//     const changeDoodle = (value: DoodleDrawing) => {\r\n//         setDoodle(value);\r\n//         props.onDrawingChanged(value);\r\n//     };\r\n\r\n//     return (\r\n//         <>\r\n//             <DoodleDrawer style={styles.drawing} drawing={doodle} onChange={changeDoodle} />\r\n//             {/* <div>\r\n//                 {JSON.stringify(doodle)}\r\n//             </div> */}\r\n//             {/* <div>\r\n//                 {JSON.stringify(decodeDoodleDrawing(encodeDoodleDrawing(doodle)))}\r\n//             </div> */}\r\n\r\n//             {/* <div>\r\n//                 {encodeDoodleDrawing(doodle).doodleText}\r\n//             </div> */}\r\n//             {/* <div>\r\n//                 {encodeDoodleDrawing(decodeDoodleDrawing(encodeDoodleDrawing(doodle))).doodleText}\r\n//             </div>  */}\r\n//         </>\r\n//     );\r\n// };\r\n\r\n\r\nexport const DoodleDrawerView = (props: { style: { width: number, height: number, color: string, backgroundColor: string }, drawing: DoodleDrawing, onChange: (drawing: DoodleDrawing) => void }) => {\r\n    const { style, drawing, onChange } = props;\r\n    const scale = style.width / drawing.width;\r\n\r\n    const [segment, setSegment] = useState(null as null | DoodleSegment);\r\n    const segmentClientStart = useRef(null as null | { clientX: number, clientY: number, x: number, y: number });\r\n    const divHost = useRef(null as null | HTMLDivElement);\r\n\r\n    type Ev = React.SyntheticEvent;\r\n\r\n    const onIgnore = (e: Ev) => {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        e.nativeEvent.cancelBubble = true;\r\n        e.nativeEvent.returnValue = false;\r\n        return false;\r\n    };\r\n\r\n    const onPressIn = (event: (Ev) & { clientX?: number, clientY?: number }, pos?: { clientX: number, clientY: number }) => {\r\n        // console.log(`onPressIn`, { event, pos });\r\n        const div = divHost.current;\r\n        if (!div) { return onIgnore(event); }\r\n\r\n        const rect = div.getBoundingClientRect();\r\n\r\n\r\n        const p = {\r\n            clientX: pos?.clientX ?? event.clientX ?? 0,\r\n            clientY: pos?.clientY ?? event.clientY ?? 0,\r\n        };\r\n\r\n        segmentClientStart.current = {\r\n            clientX: p.clientX,\r\n            clientY: p.clientY,\r\n            x: Math.floor((p.clientX - rect.x) / scale),\r\n            y: Math.floor((p.clientY - rect.y) / scale),\r\n        };\r\n\r\n        setSegment({\r\n            points: [{\r\n                x: segmentClientStart.current.x,\r\n                y: segmentClientStart.current.y,\r\n            }],\r\n        });\r\n\r\n        return onIgnore(event);\r\n    };\r\n    const onPressOut = (event: Ev) => {\r\n        // console.log(`onPressOut`, { event });\r\n        const s = segment;\r\n        if (!s) { return onIgnore(event); }\r\n\r\n        onChange({\r\n            ...drawing,\r\n            segments: [...drawing.segments, s],\r\n        });\r\n        setSegment(null);\r\n        segmentClientStart.current = null;\r\n\r\n        return onIgnore(event);\r\n    };\r\n    const onMove = (pos: { x: number, y: number }) => {\r\n        setSegment(s => {\r\n            if (!s) { return null; }\r\n            const lastPos = s.points[s.points.length - 1];\r\n            if (Math.abs(lastPos.x - pos.x) + Math.abs(lastPos.y - pos.y) <= 2) {\r\n                return s;\r\n            }\r\n            return { points: [...s.points, pos] };\r\n        });\r\n    };\r\n    const onClientMove = (event: (Ev) & { clientX?: number, clientY?: number }, pos?: { clientX: number, clientY: number }) => {\r\n        if (!segmentClientStart.current) {\r\n            return onIgnore(event);\r\n        }\r\n\r\n        // console.log(`onClientMove`, { event, pos });\r\n        const p = {\r\n            clientX: pos?.clientX ?? event.clientX ?? 0,\r\n            clientY: pos?.clientY ?? event.clientY ?? 0,\r\n        };\r\n        const dPos = {\r\n            x: Math.floor((p.clientX - segmentClientStart.current.clientX) / scale) + segmentClientStart.current.x,\r\n            y: Math.floor((p.clientY - segmentClientStart.current.clientY) / scale) + segmentClientStart.current.y,\r\n        };\r\n\r\n        onMove(dPos);\r\n        return onIgnore(event);\r\n    };\r\n\r\n    // useEffect(() => {\r\n    //     console.log(`divHost`, { divHost });\r\n    //     const div = divHost.current;\r\n    //     if (!div) { return () => { }; }\r\n\r\n    //     const onTouchStart = (x: Event) => onPressIn(x, (x as TouchEvent).touches[0]);\r\n    //     const onTouchMove = (x: Event) => onClientMove(x, (x as TouchEvent).touches[0]);\r\n\r\n    //     div.addEventListener(`mouseDown`, onPressIn, { passive: false });\r\n    //     div.addEventListener(`onTouchStart`, onTouchStart, { passive: false });\r\n    //     div.addEventListener(`onMouseUp`, onPressOut, { passive: false });\r\n    //     div.addEventListener(`onTouchEnd`, onPressOut, { passive: false });\r\n    //     div.addEventListener(`onMouseLeave`, onPressOut, { passive: false });\r\n    //     div.addEventListener(`onTouchEndCapture`, onPressOut, { passive: false });\r\n    //     div.addEventListener(`onMouseMove`, onClientMove, { passive: false });\r\n    //     div.addEventListener(`onTouchMove`, onTouchMove, { passive: false });\r\n\r\n    //     return () => {\r\n    //         div.removeEventListener(`mouseDown`, onPressIn);\r\n    //         div.removeEventListener(`onTouchStart`, onTouchStart);\r\n    //         div.removeEventListener(`onMouseUp`, onPressOut);\r\n    //         div.removeEventListener(`onTouchEnd`, onPressOut);\r\n    //         div.removeEventListener(`onMouseLeave`, onPressOut);\r\n    //         div.removeEventListener(`onTouchEndCapture`, onPressOut);\r\n    //         div.removeEventListener(`onMouseMove`, onClientMove);\r\n    //         div.removeEventListener(`onTouchMove`, onTouchMove);\r\n    //     };\r\n    // }, [divHost.current]);\r\n\r\n    useEffect(() => {\r\n        // console.log(`Disable scroll on touch`);\r\n        // Disable document scroll\r\n        const onIgnoreNative = (e: Event) => {\r\n            // If not drawing, don't ignore\r\n            if (!segmentClientStart.current) { return true; }\r\n\r\n            // console.log(`Prevent scroll on touch`);\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            e.cancelBubble = true;\r\n            e.returnValue = false;\r\n            return false;\r\n        };\r\n        document.addEventListener(`touchmove`, onIgnoreNative, { passive: false });\r\n        return () => {\r\n            document.removeEventListener(`touchmove`, onIgnoreNative);\r\n        };\r\n    }, []);\r\n\r\n    return (\r\n        <>\r\n            <div style={{ position: `relative`, width: style.width, height: style.height, backgroundColor: style.backgroundColor }}>\r\n                <svg style={{ width: style.width, height: style.height }} viewBox={`0 0 ${drawing.width} ${drawing.height}`} preserveAspectRatio='none' xmlns='http://www.w3.org/2000/svg'>\r\n                    {drawing.segments.map((x, i) => (\r\n                        <path key={i} d={doodleSegmentToSvgPath_line(x)} stroke={style.color} fill='transparent' />\r\n                    ))}\r\n                    {segment && (\r\n                        <path d={doodleSegmentToSvgPath_line(segment)} stroke={style.color} fill='transparent' />\r\n                    )}\r\n                </svg>\r\n                <div ref={divHost} style={{ position: `absolute`, left: 0, right: 0, top: 0, bottom: 0, zIndex: 10 }}\r\n                    onMouseDown={onPressIn}\r\n                    onMouseUp={onPressOut}\r\n                    onMouseMove={onClientMove}\r\n                    onMouseLeave={onPressOut}\r\n                    onTouchStart={x => onPressIn(x, x.touches[0])}\r\n                    onTouchEnd={onPressOut}\r\n                    onTouchCancel={onPressOut}\r\n                    onTouchMove={x => onClientMove(x, x.touches[0])}\r\n                    onTouchEndCapture={onPressOut}\r\n                />\r\n            </div>\r\n            {/* <div>{doodleToSvg(drawing)}</div>\r\n            <div>{encodeDoodleDrawing(drawing).doodleText}</div> */}\r\n        </>\r\n    );\r\n};\r\n\r\nexport const DoodleDisplayView = ({ style, drawing }: { style: { width: number, height: number, color: string, backgroundColor: string }, drawing: DoodleDrawing }) => {\r\n    return (\r\n        <div style={{ width: style.width, height: style.height, backgroundColor: style.backgroundColor }}>\r\n            <svg style={{ width: style.width, height: style.height }} viewBox={`0 0 ${drawing.width} ${drawing.height}`} preserveAspectRatio='none' xmlns='http://www.w3.org/2000/svg'>\r\n                {drawing.segments.map((x, i) => (\r\n                    <path key={i} d={doodleSegmentToSvgPath_line(x)} stroke={style.color} fill='transparent' />\r\n                ))}\r\n            </svg>\r\n        </div>\r\n    );\r\n};\r\n"],"sourceRoot":""}