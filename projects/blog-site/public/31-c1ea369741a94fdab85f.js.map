{"version":3,"sources":["webpack:///D:/Projects/rick-love-master/code/games/educational-games/multiples-snake.tsx"],"names":["leaderboardService","createLeaderboard","storageKey","sortKey","x","score","scoreColumns","name","getValue","timeMs","toLocaleString","undefined","minimumFractionDigits","maximumFractionDigits","EducationalGame_MultiplesSnake","props","useState","key","startTime","Date","now","gameOverTime","gameScore","setGameScore","createDefaultGameBoardState","gameBoard","setGameBoard","gameInput","setGameInput","lastGameBoard","useRef","leaderboard","useLeaderboard","getScore","onGameOver","s","onMove","value","newGameBoard","current","body","push","position","player","oldPlayerCell","columns","col","cells","row","newPlayerCell","state","isGameOver","updateBoard","ProgressGameService","onCorrect","moveBody","length","maxMultiple","isGameWon","setTimeout","nextInputState","game","gameInputState","createGameInputState","useEffect","style","marginTop","marginBottom","padding","alignItems","width","GameScore","GameBoard","focus","GameInput","LeaderboardArea","gameOver","onScoreSaved","maxTimes","Array","map","i","r","j","bodyIndex","connected","t","b","l","randomIndex","board","boardRaw","forEach","c","cellRaw","cell","getConnection","m","lastBody","nextBody","updateBoardPosition","kind","styles","cellView","height","backgroundColor","borderWidth","borderColor","borderStyle","justifyContent","focusCellView","cellHeaderView","focusCellHeaderView","cellText","fontFamily","fontSize","cellHeaderText","color","focusCellHeaderText","getCellStyle","boardTick","bodyLength","borderTopColor","borderBottomColor","borderLeftColor","borderRightColor","setBoardTick","id","setInterval","clearInterval","flexDirection","getCellText","nextCells","filter","isOnSquare","buttons","text","onPress","shuffle","inputStyles","outerContainer","container","margin","buttonView","buttonText","y","setY","Math","max","console","log","transform","scoreStyles","flex","mistakesText","setTimeMessage","scoreMessage","setScoreMessage"],"mappings":"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","file":"31-c1ea369741a94fdab85f.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport { View, Text, TouchableOpacity } from 'react-native-lite';\r\nimport { shuffle } from 'utils/arrays';\r\nimport { randomIndex } from 'utils/random';\r\nimport { createLeaderboard } from './components/leaderboard';\r\nimport { ProgressGameService } from './progress-games/progress-game';\r\n\r\nconst leaderboardService = createLeaderboard<{\r\n    score: number;\r\n    timeMs: number;\r\n}>({\r\n    storageKey: `MultiplesSnakeLeaderboard`,\r\n    sortKey: x => x.score,\r\n    scoreColumns: [\r\n        { name: `Time`, getValue: x => `${(x.timeMs / 1000).toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}` },\r\n        { name: `Score`, getValue: x => `${x.score}` },\r\n    ],\r\n});\r\n\r\nexport const EducationalGame_MultiplesSnake = (props: {}) => {\r\n\r\n    const [gameScore, setGameScore] = useState({ key: 0, startTime: Date.now(), gameOverTime: undefined, score: 0 } as GameScoreState & { key: number });\r\n    const [gameBoard, setGameBoard] = useState(createDefaultGameBoardState());\r\n    const [gameInput, setGameInput] = useState(null as null | GameInputState);\r\n    const lastGameBoard = useRef(gameBoard);\r\n\r\n    const leaderboard = leaderboardService.useLeaderboard({\r\n        getScore: () => ({ score: gameScore.score, timeMs: (gameScore.gameOverTime ?? Date.now()) - gameScore.startTime }),\r\n    });\r\n\r\n    const onGameOver = () => {\r\n        setGameScore(s => ({ ...s, gameOverTime: Date.now(), key: s.key + 1 }));\r\n    };\r\n\r\n    const onScoreSaved = () => {\r\n        // Restart Game\r\n        const newGameBoard = createDefaultGameBoardState();\r\n        setGameScore({ key: 0, startTime: Date.now(), gameOverTime: undefined, score: 0 });\r\n        setGameBoard(newGameBoard);\r\n        nextInputState(newGameBoard);\r\n    };\r\n\r\n    const onMove = (value: { col: number, row: number }) => {\r\n        const newGameBoard = { ...lastGameBoard.current };\r\n\r\n        // Add Body in old position\r\n        newGameBoard.body.push({ position: newGameBoard.player.position });\r\n\r\n        // Add Score (of old cell, so end game will be correct)\r\n        const oldPlayerCell = newGameBoard.columns[newGameBoard.player.position.col].cells[newGameBoard.player.position.row];\r\n        setGameScore(s => ({ ...s, score: s.score + oldPlayerCell.value }));\r\n\r\n        // Move Player\r\n        newGameBoard.player.position = value;\r\n        const newPlayerCell = newGameBoard.columns[newGameBoard.player.position.col].cells[newGameBoard.player.position.row];\r\n\r\n\r\n        // Player Dead\r\n        if (newPlayerCell.state === `body`) {\r\n            newGameBoard.isGameOver = true;\r\n            updateBoard(newGameBoard);\r\n            setGameBoard(newGameBoard);\r\n            onGameOver();\r\n            return;\r\n        }\r\n\r\n        ProgressGameService.onCorrect();\r\n\r\n        // Update body\r\n        moveBody(newGameBoard);\r\n\r\n        // Game Won\r\n        if (newGameBoard.body.length + 1 === maxMultiple * maxMultiple) {\r\n            newGameBoard.isGameWon = true;\r\n            setGameScore(s => ({ ...s, score: s.score + newPlayerCell.value }));\r\n            updateBoard(newGameBoard);\r\n            setGameBoard(newGameBoard);\r\n            onGameOver();\r\n            return;\r\n        }\r\n\r\n        // const col = newGameBoard.columns.find(x => x.col === value.col);\r\n        // if (col) {\r\n        //     col.maxTimesCorrect = value.row;\r\n        // };\r\n        setGameBoard(newGameBoard);\r\n        setTimeout(() => {\r\n            nextInputState(newGameBoard);\r\n        }, 100);\r\n    };\r\n\r\n    const nextInputState = (game: GameBoardState) => {\r\n        const gameInputState = createGameInputState(game, onMove);\r\n        setGameInput(gameInputState);\r\n    };\r\n\r\n    useEffect(() => {\r\n        nextInputState(gameBoard);\r\n    }, []);\r\n\r\n    lastGameBoard.current = gameBoard;\r\n\r\n    return (\r\n        <>\r\n            <View style={{ marginTop: 50, marginBottom: 150, padding: 2, alignItems: `center` }} >\r\n                <View style={{ width: 24 * 12 + 4 }}>\r\n                    <GameScore gameScore={gameScore} />\r\n                    <GameBoard gameBoard={gameBoard} focus={gameBoard.player.position ?? { col: 0, row: 0 }} />\r\n                    {gameInput && !gameScore.gameOverTime && <GameInput gameInput={gameInput} />}\r\n                    <leaderboard.LeaderboardArea gameOver={!!gameScore.gameOverTime} onScoreSaved={onScoreSaved} />\r\n                </View>\r\n            </View>\r\n        </>\r\n    );\r\n};\r\n\r\n\r\ntype GameBoardState = {\r\n    key: number;\r\n    isGameOver: boolean;\r\n    isGameWon: boolean;\r\n    maxTimes: number;\r\n    columns: {\r\n        col: number;\r\n        cells: GameBoardCell[];\r\n    }[];\r\n    player: {\r\n        position: GameBoardPosition;\r\n    };\r\n    body: {\r\n        position: GameBoardPosition;\r\n    }[];\r\n};\r\n\r\ntype GameBoardPosition = {\r\n    col: number;\r\n    row: number;\r\n};\r\n\r\ntype GameBoardCell = {\r\n    col: number;\r\n    row: number;\r\n    value: number;\r\n    state: 'blank' | 'body' | 'player';\r\n    bodyIndex: number;\r\n    connected: {\r\n        t: boolean;\r\n        b: boolean;\r\n        l: boolean;\r\n        r: boolean;\r\n    };\r\n};\r\n\r\nconst maxMultiple = 12;\r\n\r\nconst createDefaultGameBoardState = (): GameBoardState => {\r\n\r\n    const gameBoard: GameBoardState = {\r\n        key: 0,\r\n        isGameOver: false,\r\n        isGameWon: false,\r\n        maxTimes: maxMultiple,\r\n        columns: [...new Array(maxMultiple)].map((x, i) => ({\r\n            col: i,\r\n            cells: [...new Array(maxMultiple)].map((r, j) => ({\r\n                col: i,\r\n                row: j,\r\n                value: (i + 1) * (j + 1),\r\n                state: `blank`,\r\n                bodyIndex: 0,\r\n                connected: {\r\n                    t: false,\r\n                    b: false,\r\n                    l: false,\r\n                    r: false,\r\n                },\r\n            })),\r\n        })),\r\n        player: { position: { col: randomIndex(maxMultiple), row: randomIndex(maxMultiple) } },\r\n        body: [],\r\n    };\r\n\r\n    // Randomly place player\r\n    updateBoard(gameBoard);\r\n\r\n    return gameBoard;\r\n};\r\n\r\nlet tick = 0;\r\nconst moveBody = (board: GameBoardState) => {\r\n    updateBoard(board);\r\n    const newBoard = board;\r\n\r\n    // Shrink Body\r\n    tick++;\r\n    // if (tick % 2 === 1) {\r\n    //     newBoard.body.shift();\r\n    // }\r\n\r\n    // const p = board.player;\r\n    // board.monsters.forEach(mon => {\r\n    //     const m = mon;\r\n    //     const colDiff = p.position.col - m.position.col;\r\n    //     const rowDiff = p.position.row - m.position.row;\r\n    //     if (Math.abs(colDiff) >= Math.abs(rowDiff)) {\r\n    //         m.position = { ...m.position, col: m.position.col + Math.sign(colDiff) };\r\n    //     } else {\r\n    //         m.position = { ...m.position, row: m.position.row + Math.sign(rowDiff) };\r\n    //     }\r\n\r\n\r\n    // });\r\n\r\n    // // Spawn random monster\r\n    // if (Math.random() < 0.25) {\r\n    //     const newMonster = { position: { col: randomIndex(maxMultiple), row: randomIndex(maxMultiple) } };\r\n    //     if (Math.random() < 0.5) {\r\n    //         if (Math.random() < 0.5) {\r\n    //             newMonster.position.col = 0;\r\n    //         } else {\r\n    //             newMonster.position.col = maxMultiple - 1;\r\n    //         }\r\n    //     } else {\r\n    //         // eslint-disable-next-line no-lonely-if\r\n    //         if (Math.random() < 0.5) {\r\n    //             newMonster.position.row = 0;\r\n    //         } else {\r\n    //             newMonster.position.row = maxMultiple - 1;\r\n    //         }\r\n    //     }\r\n\r\n    //     board.monsters.push(newMonster);\r\n    // }\r\n\r\n    // // Remove monsters that run into answer\r\n    // const monsters = [...board.monsters];\r\n    // const deadMonsters = monsters.filter(m => board.columns[m.position.col].cells[m.position.row].state === `answer`);\r\n    // const liveMonsters = monsters.filter(m => board.columns[m.position.col].cells[m.position.row].state !== `answer`);\r\n\r\n    // // Dead monsters destroy answer\r\n    // deadMonsters.forEach(m => {\r\n    //     newBoard.columns[m.position.col].cells[m.position.row].state = `blank`;\r\n    // });\r\n\r\n    // newBoard.monsters = liveMonsters;\r\n\r\n    updateBoard(newBoard);\r\n};\r\n\r\nconst updateBoard = (boardRaw: GameBoardState) => {\r\n    const board = boardRaw;\r\n    board.key += 1;\r\n    board.columns.forEach(c => c.cells.forEach(cellRaw => {\r\n        const cell = cellRaw;\r\n        if (cell.state === `body`) { cell.state = `blank`; }\r\n        if (cell.state === `player`) { cell.state = `body`; }\r\n\r\n        cell.connected = {\r\n            t: false,\r\n            b: false,\r\n            l: false,\r\n            r: false,\r\n        };\r\n    }));\r\n\r\n    const getConnection = (m: { position: GameBoardPosition }, lastBody?: { position: GameBoardPosition }, nextBody?: { position: GameBoardPosition }) => {\r\n        const connected = {\r\n            t: (m.position.col === lastBody?.position.col && m.position.row < lastBody?.position.row) || (m.position.col === nextBody?.position.col && m.position.row < nextBody?.position.row),\r\n            b: (m.position.col === lastBody?.position.col && m.position.row > lastBody?.position.row) || (m.position.col === nextBody?.position.col && m.position.row > nextBody?.position.row),\r\n            l: (m.position.row === lastBody?.position.row && m.position.col > lastBody?.position.col) || (m.position.row === nextBody?.position.row && m.position.col > nextBody?.position.col),\r\n            r: (m.position.row === lastBody?.position.row && m.position.col < lastBody?.position.col) || (m.position.row === nextBody?.position.row && m.position.col < nextBody?.position.col),\r\n        };\r\n        return connected;\r\n    };\r\n\r\n    board.body.forEach((m, i) => {\r\n        updateBoardPosition(board, m.position, `body`, board.body.length - i, getConnection(m, board.body[i - 1], board.body[i + 1] ?? board.player));\r\n    });\r\n\r\n    updateBoardPosition(board, board.player.position, `player`, 0, getConnection(board.player, board.body[board.body.length - 1], undefined));\r\n};\r\n\r\nconst updateBoardPosition = (boardRaw: GameBoardState, position: GameBoardPosition, kind: 'player' | 'body', bodyIndex: number, connected: {\r\n    t: boolean;\r\n    b: boolean;\r\n    l: boolean;\r\n    r: boolean;\r\n}) => {\r\n    const board = boardRaw;\r\n    board.columns[position.col].cells[position.row].state = kind;\r\n    board.columns[position.col].cells[position.row].bodyIndex = bodyIndex;\r\n    board.columns[position.col].cells[position.row].connected = connected;\r\n    board.key += 1;\r\n};\r\n\r\nconst styles = {\r\n    cellView: {\r\n        width: 24,\r\n        height: 24,\r\n        backgroundColor: `rgba(0,0,0,0.75)`,\r\n        borderWidth: 1,\r\n        borderColor: `#111133`,\r\n        borderStyle: `solid`,\r\n        justifyContent: `center`,\r\n        alignItems: `center`,\r\n    },\r\n    focusCellView: {\r\n        width: 24,\r\n        height: 24,\r\n        borderWidth: 1,\r\n        borderColor: `#66FF66`,\r\n        borderStyle: `solid`,\r\n        justifyContent: `center`,\r\n        alignItems: `center`,\r\n    },\r\n    cellHeaderView: {\r\n        width: 24,\r\n        height: 24,\r\n        backgroundColor: `rgba(0,0,0,0.5)`,\r\n        borderWidth: 1,\r\n        borderColor: `#111133`,\r\n        borderStyle: `solid`,\r\n        justifyContent: `center`,\r\n        alignItems: `center`,\r\n    },\r\n    focusCellHeaderView: {\r\n        width: 24,\r\n        height: 24,\r\n        backgroundColor: `rgba(0,0,0,0.5)`,\r\n        borderWidth: 1,\r\n        borderColor: `#111133`,\r\n        borderStyle: `solid`,\r\n        justifyContent: `center`,\r\n        alignItems: `center`,\r\n    },\r\n    cellText: {\r\n        fontFamily: `\"Lucida Console\", Monaco, monospace`,\r\n        fontSize: 12,\r\n    },\r\n    cellHeaderText: {\r\n        fontFamily: `\"Lucida Console\", Monaco, monospace`,\r\n        fontSize: 12,\r\n        color: `#333300`,\r\n    },\r\n    focusCellHeaderText: {\r\n        fontFamily: `\"Lucida Console\", Monaco, monospace`,\r\n        fontSize: 12,\r\n        color: `#FFFF00`,\r\n    },\r\n} as const;\r\n\r\nconst getCellText = (cell: GameBoardCell, isGameOver: boolean, isGameWon: boolean) => {\r\n    return cell.state === `body` ? `${cell.value}`\r\n        : cell.state === `player` && isGameWon ? `😎`\r\n            : cell.state === `player` && isGameOver ? `💀`\r\n                : cell.state === `player` ? `😀`\r\n                    : ``;\r\n};\r\n\r\nconst getCellStyle = (boardTick: number, cell: GameBoardCell, bodyLength: number) => {\r\n    return {\r\n        borderTopColor: cell.connected.t ? `transparent` : styles.focusCellView.borderColor,\r\n        borderBottomColor: cell.connected.b ? `transparent` : styles.focusCellView.borderColor,\r\n        borderLeftColor: cell.connected.l ? `transparent` : styles.focusCellView.borderColor,\r\n        borderRightColor: cell.connected.r ? `transparent` : styles.focusCellView.borderColor,\r\n        // opacity: 0.6 + 0.4 * (((boardTick - cell.bodyIndex) % 10) / 10),\r\n        borderWidth: (0.4 + 0.6 * (((boardTick - cell.bodyIndex) % 10) / 10)) * 5,\r\n    };\r\n};\r\n\r\nconst GameBoard = ({ gameBoard, focus }: { gameBoard: GameBoardState, focus: { col: number, row: number } }) => {\r\n\r\n    const [boardTick, setBoardTick] = useState(0);\r\n\r\n    useEffect(() => {\r\n        const id = setInterval(() => {\r\n            setBoardTick(s => s + 1);\r\n        }, 500);\r\n        return () => clearInterval(id);\r\n    }, [/* Keep going */]);\r\n\r\n    return (\r\n        <>\r\n            <View style={{ flexDirection: `row` }} >\r\n                <View style={{ flexDirection: `column-reverse` }} >\r\n                    <View style={styles.focusCellHeaderView} >\r\n                        <Text style={styles.focusCellHeaderText} >x</Text>\r\n                    </View>\r\n                    {gameBoard.columns[0].cells.map((r) => (\r\n                        <View key={r.row} style={focus.row === r.row ? styles.focusCellHeaderView : styles.cellHeaderView} >\r\n                            <Text style={focus.row === r.row ? styles.focusCellHeaderText : styles.cellHeaderText}>{`${r.row + 1}`}</Text>\r\n                        </View>\r\n                    ))}\r\n                </View>\r\n\r\n                {gameBoard.columns.map((c) => (\r\n                    <View key={c.col} style={{ flexDirection: `column-reverse` }} >\r\n                        <View style={focus.col === c.col ? styles.focusCellHeaderView : styles.cellHeaderView} >\r\n                            <Text style={focus.col === c.col ? styles.focusCellHeaderText : styles.cellHeaderText}>{`${c.col + 1}`}</Text>\r\n                        </View>\r\n                        {c.cells.map((cell) => (\r\n                            <View key={cell.row} style={cell.state !== `blank` ? [styles.focusCellView, getCellStyle(boardTick, cell, gameBoard.body.length)] : styles.cellView} >\r\n                                <Text style={styles.cellText}>{getCellText(cell, gameBoard.isGameOver, gameBoard.isGameWon)}</Text>\r\n                            </View>\r\n                        ))}\r\n                    </View>\r\n                ))}\r\n\r\n            </View>\r\n        </>\r\n    );\r\n};\r\n\r\n\r\ntype GameInputState = {\r\n    key: string;\r\n    buttons: {\r\n        key: string;\r\n        text: string;\r\n        onPress: () => void;\r\n    }[];\r\n};\r\n\r\nconst createGameInputState = (gameBoard: GameBoardState, onMove: (value: { col: number, row: number }) => void): GameInputState => {\r\n    const { player } = gameBoard;\r\n\r\n    const nextCells = [\r\n        gameBoard.columns[player.position.col + 0]?.cells[player.position.row + 1],\r\n        gameBoard.columns[player.position.col + 0]?.cells[player.position.row - 1],\r\n        gameBoard.columns[player.position.col + 1]?.cells[player.position.row + 0],\r\n        gameBoard.columns[player.position.col - 1]?.cells[player.position.row + 0],\r\n    ].filter(x => x);\r\n\r\n\r\n    const isOnSquare = player.position.col === player.position.row;\r\n    const buttons = nextCells.map(x => ({\r\n        key: `${x.row} ${x.col}`,\r\n        text: `${x.value}${isOnSquare && player.position.col === x.col ? `↕` : isOnSquare && player.position.row === x.row ? `↔` : ``}`,\r\n        onPress: () => onMove(x),\r\n    }));\r\n\r\n    return {\r\n        key: `${gameBoard.key}`,\r\n        buttons: shuffle(buttons),\r\n    };\r\n};\r\n\r\nconst inputStyles = {\r\n    outerContainer: {\r\n        height: 150,\r\n    },\r\n    container: {\r\n        flexDirection: `row`,\r\n        justifyContent: `space-around`,\r\n        margin: 16,\r\n    },\r\n    buttonView: {\r\n        width: 48,\r\n        height: 48,\r\n        borderWidth: 2,\r\n        borderColor: `#6666FF`,\r\n        borderStyle: `solid`,\r\n        justifyContent: `center`,\r\n        alignItems: `center`,\r\n    },\r\n    buttonText: {\r\n        fontFamily: `\"Lucida Console\", Monaco, monospace`,\r\n        fontSize: 24,\r\n        color: `#FFFFFF`,\r\n    },\r\n} as const;\r\n\r\nconst GameInput = ({ gameInput }: { gameInput: GameInputState }) => {\r\n\r\n    const [y, setY] = useState(0);\r\n\r\n    useEffect(() => {\r\n        setY(100);\r\n        const id = setInterval(() => {\r\n            setY(s => Math.max(0, s - 1));\r\n        }, 50);\r\n        return () => clearInterval(id);\r\n    }, [gameInput.key]);\r\n\r\n    console.log(`GameInput`, { gameInput });\r\n    return (\r\n        <>\r\n            <View style={inputStyles.outerContainer}>\r\n                <View style={[inputStyles.container, { transform: `translate(0px,${y}px)` }]}>\r\n                    {gameInput.buttons.map(x => (\r\n                        <TouchableOpacity key={x.key} onPress={x.onPress}>\r\n                            <View style={inputStyles.buttonView}>\r\n                                <Text style={inputStyles.buttonText}>{x.text}</Text>\r\n                            </View>\r\n                        </TouchableOpacity>))}\r\n                </View>\r\n            </View>\r\n        </>\r\n    );\r\n};\r\n\r\n\r\nconst scoreStyles = {\r\n    container: {\r\n        flex: 1,\r\n        alignItems: `center`,\r\n        margin: 16,\r\n    },\r\n    text: {\r\n        fontFamily: `\"Lucida Console\", Monaco, monospace`,\r\n        fontSize: 14,\r\n        color: `#FFFF00`,\r\n    },\r\n    mistakesText: {\r\n        fontFamily: `\"Lucida Console\", Monaco, monospace`,\r\n        fontSize: 14,\r\n        color: `#FF6666`,\r\n    },\r\n} as const;\r\n\r\ntype GameScoreState = {\r\n    startTime: number;\r\n    gameOverTime?: number;\r\n    score: number;\r\n};\r\n\r\nconst GameScore = ({ gameScore }: { gameScore: GameScoreState }) => {\r\n\r\n    const [timeMessage, setTimeMessage] = useState(``);\r\n    const [scoreMessage, setScoreMessage] = useState(``);\r\n\r\n    useEffect(() => {\r\n        const id = setInterval(() => {\r\n\r\n            setScoreMessage(`${gameScore.score}`);\r\n\r\n            if (gameScore.gameOverTime) {\r\n                const timeMs = gameScore.gameOverTime - gameScore.startTime;\r\n                setTimeMessage(s => `${(timeMs / 1000).toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} seconds`);\r\n                return;\r\n            }\r\n\r\n            const timeMs = Date.now() - gameScore.startTime;\r\n            setTimeMessage(s => `${(timeMs / 1000).toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} seconds`);\r\n        }, 100);\r\n        return () => clearInterval(id);\r\n    }, [gameScore]);\r\n\r\n    // console.log(`GameInput`);\r\n    return (\r\n        <>\r\n            <View style={scoreStyles.container}>\r\n                {/* <View>\r\n                    <Text style={scoreStyles.text}>{timeMessage}</Text>\r\n                </View> */}\r\n                <View>\r\n                    <Text style={scoreStyles.text}>{scoreMessage}</Text>\r\n                </View>\r\n            </View>\r\n        </>\r\n    );\r\n};\r\n"],"sourceRoot":""}