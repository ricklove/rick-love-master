{"version":3,"sources":["webpack:///D:/Projects/rick-love-master/code/doodle/doodle-view.tsx","webpack:///D:/Projects/rick-love-master/code/doodle/doodle.ts"],"names":["DoodleView","props","useState","width","height","segments","doodle","setDoodle","style","color","backgroundColor","drawing","onChange","value","createLinePath","segment","points","length","x","y","slice","map","p","join","DoodleSvg","scale","setSegment","segmentClientStart","useRef","divHost","onIgnore","e","preventDefault","stopPropagation","nativeEvent","cancelBubble","returnValue","onPressIn","event","pos","div","current","rect","getBoundingClientRect","clientX","clientY","Math","floor","onPressOut","s","onClientMove","lastPos","abs","onMove","useEffect","onIgnoreNative","document","addEventListener","passive","removeEventListener","position","viewBox","preserveAspectRatio","xmlns","i","key","d","stroke","fill","ref","left","right","top","bottom","zIndex","onMouseDown","onMouseUp","onMouseMove","onMouseLeave","onTouchStart","touches","onTouchEnd","onTouchCancel","onTouchMove","onTouchEndCapture"],"mappings":"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","file":"20-6ba87f1a73e2cc4fa75f.js","sourcesContent":["/* eslint-disable react/no-array-index-key */\r\n/* eslint-disable jsx-a11y/no-static-element-interactions */\r\nimport React, { useState, useRef, useEffect } from 'react';\r\nimport { defaultDoodleDrawing, DoodleSegment, DoodleDrawing, encodeDoodleDrawing, decodeDoodleDrawing } from './doodle';\r\n\r\n\r\nexport const DoodleView = (props: {}) => {\r\n\r\n    const [doodle, setDoodle] = useState(defaultDoodleDrawing());\r\n    const changeDoodle = (value: DoodleDrawing) => {\r\n        setDoodle(value);\r\n\r\n        // TEST Encoding\r\n        // setDoodle(decodeDoodleDrawing(encodeDoodleDrawing(value)));\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <DoodleSvg style={{ width: 312, height: 312, color: `#FFFFFF`, backgroundColor: `#000000` }} drawing={doodle} onChange={changeDoodle} />\r\n            {/* <div>\r\n                {JSON.stringify(doodle)}\r\n            </div> */}\r\n            {/* <div>\r\n                {JSON.stringify(decodeDoodleDrawing(encodeDoodleDrawing(doodle)))}\r\n            </div> */}\r\n\r\n            {/* <div>\r\n                {encodeDoodleDrawing(doodle).doodleText}\r\n            </div> */}\r\n            {/* <div>\r\n                {encodeDoodleDrawing(decodeDoodleDrawing(encodeDoodleDrawing(doodle))).doodleText}\r\n            </div>  */}\r\n        </>\r\n    );\r\n};\r\n\r\n// const createBezierCurvePath = (segment: DoodleSegment) => {\r\n//     const delta1 = {\r\n//         x: segment.points[2].x - segment.points[1].x,\r\n//         y: segment.points[2].y - segment.points[1].y,\r\n//     };\r\n//     const controlPoint = {\r\n//         x: segment.points[1].x - delta1.x * 0.5,\r\n//         y: segment.points[1].y - delta1.y * 0.5,\r\n//     };\r\n//     return `M${segment.points[0].x} ${segment.points[0].y} Q${controlPoint.x} ${controlPoint.y} ${segment.points[1].x} ${segment.points[1].y}T${segment.points.slice(2, -1).map(p => `${p.x} ${p.y}`).join(` `)}`;\r\n// };\r\n\r\nconst createLinePath = (segment: DoodleSegment) => {\r\n    if (segment.points.length <= 0) { return ``; }\r\n    if (segment.points.length === 1) { return `M${segment.points[0].x} ${segment.points[0].y} L${segment.points[0].x} ${segment.points[0].y}`; }\r\n\r\n    return `M${segment.points[0].x} ${segment.points[0].y} L${segment.points.slice(1).map(p => `${p.x} ${p.y}`).join(` `)}`;\r\n};\r\n\r\nconst DoodleSvg = (props: { style: { width: number, height: number, color: string, backgroundColor: string }, drawing: DoodleDrawing, onChange: (drawing: DoodleDrawing) => void }) => {\r\n    const { style, drawing, onChange } = props;\r\n    const scale = style.width / drawing.width;\r\n\r\n    const [segment, setSegment] = useState(null as null | DoodleSegment);\r\n    const segmentClientStart = useRef(null as null | { clientX: number, clientY: number, x: number, y: number });\r\n    const divHost = useRef(null as null | HTMLDivElement);\r\n\r\n    type Ev = React.SyntheticEvent;\r\n\r\n    const onIgnore = (e: Ev) => {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        e.nativeEvent.cancelBubble = true;\r\n        e.nativeEvent.returnValue = false;\r\n        return false;\r\n    };\r\n\r\n    const onPressIn = (event: (Ev) & { clientX?: number, clientY?: number }, pos?: { clientX: number, clientY: number }) => {\r\n        // console.log(`onPressIn`, { event, pos });\r\n        const div = divHost.current;\r\n        if (!div) { return onIgnore(event); }\r\n\r\n        const rect = div.getBoundingClientRect();\r\n\r\n\r\n        const p = {\r\n            clientX: pos?.clientX ?? event.clientX ?? 0,\r\n            clientY: pos?.clientY ?? event.clientY ?? 0,\r\n        };\r\n\r\n        segmentClientStart.current = {\r\n            clientX: p.clientX,\r\n            clientY: p.clientY,\r\n            x: Math.floor((p.clientX - rect.x) / scale),\r\n            y: Math.floor((p.clientY - rect.y) / scale),\r\n        };\r\n\r\n        setSegment({\r\n            points: [{\r\n                x: segmentClientStart.current.x,\r\n                y: segmentClientStart.current.y,\r\n            }],\r\n        });\r\n\r\n        return onIgnore(event);\r\n    };\r\n    const onPressOut = (event: Ev) => {\r\n        // console.log(`onPressOut`, { event });\r\n        const s = segment;\r\n        if (!s) { return onIgnore(event); }\r\n\r\n        onChange({\r\n            ...drawing,\r\n            segments: [...drawing.segments, s],\r\n        });\r\n        setSegment(null);\r\n        segmentClientStart.current = null;\r\n\r\n        return onIgnore(event);\r\n    };\r\n    const onMove = (pos: { x: number, y: number }) => {\r\n        setSegment(s => {\r\n            if (!s) { return null; }\r\n            const lastPos = s.points[s.points.length - 1];\r\n            if (Math.abs(lastPos.x - pos.x) + Math.abs(lastPos.y - pos.y) <= 2) {\r\n                return s;\r\n            }\r\n            return { points: [...s.points, pos] };\r\n        });\r\n    };\r\n    const onClientMove = (event: (Ev) & { clientX?: number, clientY?: number }, pos?: { clientX: number, clientY: number }) => {\r\n        if (!segmentClientStart.current) {\r\n            return onIgnore(event);\r\n        }\r\n\r\n        // console.log(`onClientMove`, { event, pos });\r\n        const p = {\r\n            clientX: pos?.clientX ?? event.clientX ?? 0,\r\n            clientY: pos?.clientY ?? event.clientY ?? 0,\r\n        };\r\n        const dPos = {\r\n            x: Math.floor((p.clientX - segmentClientStart.current.clientX) / scale) + segmentClientStart.current.x,\r\n            y: Math.floor((p.clientY - segmentClientStart.current.clientY) / scale) + segmentClientStart.current.y,\r\n        };\r\n\r\n        onMove(dPos);\r\n        return onIgnore(event);\r\n    };\r\n\r\n    // useEffect(() => {\r\n    //     console.log(`divHost`, { divHost });\r\n    //     const div = divHost.current;\r\n    //     if (!div) { return () => { }; }\r\n\r\n    //     const onTouchStart = (x: Event) => onPressIn(x, (x as TouchEvent).touches[0]);\r\n    //     const onTouchMove = (x: Event) => onClientMove(x, (x as TouchEvent).touches[0]);\r\n\r\n    //     div.addEventListener(`mouseDown`, onPressIn, { passive: false });\r\n    //     div.addEventListener(`onTouchStart`, onTouchStart, { passive: false });\r\n    //     div.addEventListener(`onMouseUp`, onPressOut, { passive: false });\r\n    //     div.addEventListener(`onTouchEnd`, onPressOut, { passive: false });\r\n    //     div.addEventListener(`onMouseLeave`, onPressOut, { passive: false });\r\n    //     div.addEventListener(`onTouchEndCapture`, onPressOut, { passive: false });\r\n    //     div.addEventListener(`onMouseMove`, onClientMove, { passive: false });\r\n    //     div.addEventListener(`onTouchMove`, onTouchMove, { passive: false });\r\n\r\n    //     return () => {\r\n    //         div.removeEventListener(`mouseDown`, onPressIn);\r\n    //         div.removeEventListener(`onTouchStart`, onTouchStart);\r\n    //         div.removeEventListener(`onMouseUp`, onPressOut);\r\n    //         div.removeEventListener(`onTouchEnd`, onPressOut);\r\n    //         div.removeEventListener(`onMouseLeave`, onPressOut);\r\n    //         div.removeEventListener(`onTouchEndCapture`, onPressOut);\r\n    //         div.removeEventListener(`onMouseMove`, onClientMove);\r\n    //         div.removeEventListener(`onTouchMove`, onTouchMove);\r\n    //     };\r\n    // }, [divHost.current]);\r\n\r\n    useEffect(() => {\r\n        // console.log(`Disable scroll on touch`);\r\n        // Disable document scroll\r\n        const onIgnoreNative = (e: Event) => {\r\n            // If not drawing, don't ignore\r\n            if (!segmentClientStart.current) { return true; }\r\n\r\n            // console.log(`Prevent scroll on touch`);\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            e.cancelBubble = true;\r\n            e.returnValue = false;\r\n            return false;\r\n        };\r\n        document.addEventListener(`touchmove`, onIgnoreNative, { passive: false });\r\n        return () => {\r\n            document.removeEventListener(`touchmove`, onIgnoreNative);\r\n        };\r\n    }, []);\r\n\r\n    return (\r\n        <div style={{ position: `relative`, width: style.width, height: style.height, backgroundColor: style.backgroundColor }}>\r\n            <svg style={{ width: style.width, height: style.height }} viewBox={`0 0 ${drawing.width} ${drawing.height}`} preserveAspectRatio='none' xmlns='http://www.w3.org/2000/svg'>\r\n                {drawing.segments.map((x, i) => (\r\n                    <path key={i} d={createLinePath(x)} stroke={style.color} fill='transparent' />\r\n                ))}\r\n                {segment && (\r\n                    <path d={createLinePath(segment)} stroke={style.color} fill='transparent' />\r\n                )}\r\n            </svg>\r\n            <div ref={divHost} style={{ position: `absolute`, left: 0, right: 0, top: 0, bottom: 0, zIndex: 10 }}\r\n                onMouseDown={onPressIn}\r\n                onMouseUp={onPressOut}\r\n                onMouseMove={onClientMove}\r\n                onMouseLeave={onPressOut}\r\n                onTouchStart={x => onPressIn(x, x.touches[0])}\r\n                onTouchEnd={onPressOut}\r\n                onTouchCancel={onPressOut}\r\n                onTouchMove={x => onClientMove(x, x.touches[0])}\r\n                onTouchEndCapture={onPressOut}\r\n            > </div>\r\n        </div>\r\n    );\r\n};\r\n","\r\nexport type DoodleDrawing = {\r\n    width: number;\r\n    height: number;\r\n    segments: DoodleSegment[];\r\n};\r\nexport type DoodleSegment = {\r\n    points: { x: number, y: number }[];\r\n};\r\n\r\n// const sampleDrawing: DoodleDrawing = {\r\n//     width: 128,\r\n//     height: 128,\r\n//     segments: [{\r\n//         points: [\r\n//             { x: 10, y: 10 },\r\n//             { x: 50, y: 10 },\r\n//             { x: 50, y: 50 },\r\n//             { x: 10, y: 50 },\r\n//             { x: 10, y: 10 },\r\n//         ],\r\n//     }],\r\n// };\r\n\r\nexport const defaultDoodleDrawing = (): DoodleDrawing => ({\r\n    width: 104,\r\n    height: 104,\r\n    segments: [],\r\n});\r\n\r\nexport type DoodleDrawingEncoded = {\r\n    doodleText: string;\r\n};\r\ntype DoodleDrawingEncodedObj = {\r\n    w: number;\r\n    h: number;\r\n    s: {\r\n        x: number;\r\n        y: number;\r\n        p: string;\r\n    }[];\r\n};\r\nconst encodeDoodleSegmentPoints = (points: { x: number, y: number }[]): string => {\r\n    if (points.length <= 0) { return ``; }\r\n    let last = points[0];\r\n    let t = ``;\r\n\r\n    points.slice(1).forEach(p => {\r\n        t += `${p.x - last.x},${p.y - last.y};`;\r\n        last = p;\r\n    });\r\n\r\n    return t;\r\n};\r\nconst decodeDoodleSegmentPoints = (x: number, y: number, pointsString: string): { x: number, y: number }[] => {\r\n    if (!pointsString) { return [{ x, y }]; }\r\n    let last = { x, y };\r\n    const pointRelPos = pointsString.split(`;`).filter(p => p);\r\n    const points = pointRelPos.map(p => {\r\n        const parts = p.split(`,`);\r\n        const point = {\r\n            x: last.x + Number.parseInt(parts[0], 10),\r\n            y: last.y + Number.parseInt(parts[1], 10),\r\n        };\r\n        last = point;\r\n        return point;\r\n    });\r\n\r\n    return [...points];\r\n};\r\n\r\nexport const encodeDoodleDrawing = (doodle: DoodleDrawing): DoodleDrawingEncoded => {\r\n    const o: DoodleDrawingEncodedObj = {\r\n        w: doodle.width,\r\n        h: doodle.height,\r\n        s: doodle.segments.map(x => ({\r\n            x: x.points[0].x,\r\n            y: x.points[0].y,\r\n            p: encodeDoodleSegmentPoints(x.points),\r\n        })),\r\n    };\r\n    return { doodleText: JSON.stringify(o) };\r\n};\r\nexport const decodeDoodleDrawing = (doodle: DoodleDrawingEncoded): DoodleDrawing => {\r\n    const o: DoodleDrawingEncodedObj = JSON.parse(doodle.doodleText) as DoodleDrawingEncodedObj;\r\n    return {\r\n        width: o.w,\r\n        height: o.h,\r\n        segments: o.s.map(p => {\r\n            return {\r\n                points: [{ x: p.x, y: p.y }, ...decodeDoodleSegmentPoints(p.x, p.y, p.p)],\r\n            };\r\n        }),\r\n    };\r\n};\r\n"],"sourceRoot":""}