
<html>
<head>
    <style>
    html, body, div, span, applet, object, iframe,
    h1, h2, h3, h4, h5, h6, p, blockquote, pre,
    a, abbr, acronym, address, big, cite, code,
    del, dfn, em, img, ins, kbd, q, s, samp,
    small, strike, strong, sub, sup, tt, var,
    b, u, i, center,
    dl, dt, dd, ol, ul, li,
    fieldset, form, label, legend,
    table, caption, tbody, tfoot, thead, tr, th, td,
    article, aside, canvas, details, embed, 
    figure, figcaption, footer, header, hgroup, 
    menu, nav, output, ruby, section, summary,
    time, mark, audio, video {
        margin: 0;
        padding: 0;
        border: 0;
        font-size: 100%;
        font: inherit;
        vertical-align: baseline;
    }
    /* HTML5 display-role reset for older browsers */
    article, aside, details, figcaption, figure, 
    footer, header, hgroup, menu, nav, section {
        display: block;
    }
    body {
        line-height: 1;
    }
    ol, ul {
        list-style: none;
    }
    blockquote, q {
        quotes: none;  
    }
    blockquote:before, blockquote:after,
    q:before, q:after {
        content: '';
        content: none;
    }
    table {
        border-collapse: collapse;
        border-spacing: 0;
    }

    body { 
        background: #000000;
    }
    body, div {
        display: flex;
        flex: 1;
        justify-content: center;
        align-items: center;
        max-width: 100%;
        max-height: 100%;
    }
    </style>
</head>
<body>

    <div id='host'></div>
    
<script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>

    <script>
    (function (exports) {
  'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  /* eslint-disable no-return-assign */

  /* eslint-disable no-multi-assign */

  /* eslint-disable @typescript-eslint/no-unused-expressions */

  /* eslint-disable no-bitwise */
  // FROM: https://stackoverflow.com/a/47593316/567524
  function xmur3(str) {
    var h = 1779033703 ^ str.length;

    for (var i = 0; i < str.length; i++) {
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = h << 13 | h >>> 19;
    }

    return function () {
      h = Math.imul(h ^ h >>> 16, 2246822507);
      h = Math.imul(h ^ h >>> 13, 3266489909);
      return (h ^= h >>> 16) >>> 0;
    };
  }

  function mulberry32(a) {
    return function () {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  var createRandomGenerator = function createRandomGenerator(hash) {
    var seed = xmur3(hash)();
    return {
      random: mulberry32(seed)
    };
  };

  var metadata = {
    key: "nft-text-adventure",
    name: "NFT Text Adventure",
    description: "NFT Text Adventure is a game where actions are chosen by the NFT community",
    author: "Rick Love & the NFT Community"
  }; // https://cloudapps.herokuapp.com/imagetoascii/
  // .:*I$VMoun-
  // .!"#$%&O0olWM()*+-{|}~<>[]
  // .,:|'Oo(){}[]
  // .-:SOo

  var asciiArt_manArmUp = "\n.........()-,.......................\n.......(),...}:.....................\n..........\"}:==::>..................\n.....()::}:-==:::::>................\n..........,==:::::::::}.............\n.....():\"}..:::::::::::::::.........\n.............:::-...<::::::::::.....\n...........():..........::::::::::..\n..........................-::::::::.\n.........oooSS:.............-::::::.\n......:SSOOOoo::...........:::::::-.\n......oOoo:o::..:.........::::::::..\n.....:OOo:...:::::........::::::::..\n......oOS:::::::::........o::::::...\n......-oOo::::...::..:ooooooo:::....\n..........::::--::::oooooooooo:.....\n...........:::::::oooooooooooo:.....\n....-:oooo:ooooooooooooooooooo:.....\n".trim().replace(/\./g, " ");
  var items = [{
    key: "torch",
    name: "Torch",
    description: "This torch will be your light when all other lights go out..."
  }, {
    key: "torch_lit",
    name: "Lit Torch",
    description: "This torch it lit!"
  }, {
    key: "rope",
    name: "Knife",
    description: "That's not a knife... This is a knife!"
  }];

  /** There is only a single linear progression, all other choices end in death */
  var story = [{
    title: "NFT Text Adventure",
    asciiArt: asciiArt_manArmUp,
    description: "",
    inventory: [],
    actions: [{
      name: "play",
      description: "",
      gameOver: false
    }]
  }, {
    title: "Cold",
    // asciiArt: asciiArt_manArmUp,
    description: "\n\nCold, damp, wet... you wake up shivering. \n\nWhen you open your eyes, everything is still dark.\n\nYou can't see anything, but you can feel that you are lying on a cold hard surface...",
    glitch: {
      ratio: 0.07,
      messages: ["HELP ME!", "Who are you?", "What are you?", "How are you?", "Where are you?", "Why are you?", "I'm cold", "I'm alone", "I'm afraid"]
    },
    inventory: [],
    actions: [{
      name: "search the ground",
      description: "You search the ground...",
      gameOver: "\nAs you feel around your position, you realize that there is no ground anywhere around you.\n                \nThere is no way you can escape.\n\n"
    }, {
      name: "call for help",
      description: "You call for help...",
      gameOver: "\nSuddenly you hear scratching quickly coming towards you.\n                \nYou feel a sharp pain in your stomach. Your muscles spasm for a moment, but then you are no longer able to move.\n"
    }, {
      name: "listen",
      description: "You carefully listen without making a sound...",
      gameOver: false
    }]
  }, {
    title: "Whispers",
    // asciiArt: asciiArt_manArmUp,
    description: "\n\nIn the distance, you hear the slight brookling of water flowing over stones, but nothing else at first.\n\nThen, you hear something you did not expect, a whisper in your ear that says: \n\n\"Do not move... They will see you...\"",
    glitch: {
      ratio: 0.03,
      messages: ["HELP ME!", "Who are you?", "What are you?", "How are you?", "Where are you?", "Why are you?", "I'm cold", "I'm alone", "I'm afraid"]
    },
    inventory: [],
    actions: [{
      name: "remain still",
      description: "You decide not moving is a good idea for now..."
    }, {
      name: "move away",
      description: "You jerk away from the whisper..."
    }, {
      name: "stand up",
      description: "You push yourself off the ground..."
    }]
  }];
  var createNftAdventure_nftTextAdventure = function createNftAdventure_nftTextAdventure() {
    return {
      metadata: metadata,
      items: items,
      story: story
    };
  };

  var drawGameStep = function drawGameStep(_ref) {
    var _ref2, _action$name;

    var step = _ref.step,
        actionIndex = _ref.actionIndex,
        s = _ref.s,
        timeMsRaw = _ref.timeMs,
        frame = _ref.frame,
        seed = _ref.seed,
        input = _ref.input,
        mode = _ref.mode;

    if (!step) {
      return {
        done: true
      };
    }

    var timeMs = timeMsRaw;

    var _createRandomGenerato = createRandomGenerator("".concat(seed).concat(step).concat(Math.floor(timeMs / 250))),
        randomSlow = _createRandomGenerato.random;

    var _createRandomGenerato2 = createRandomGenerator("".concat(seed).concat(step).concat(Math.floor(timeMs / 50))),
        random = _createRandomGenerato2.random;

    var shouldGlitch = step.glitch && randomSlow() > 1.0 - step.glitch.ratio;
    var charsPerSecond = 30;
    var charLength = Math.floor(timeMs / 1000 * charsPerSecond);
    s.background(s.color(25 - 25 * Math.cos(2 * Math.PI * timeMs / 1000 / 10), 0, 0)); // s.background(0);

    s.fill(s.color(255, 255, 255));
    s.textFont("monospace");
    s.textAlign("left");
    s.textSize(14);
    var LINE = 20;
    var PAD = 4;
    var actionCount = step.actions.length;

    var drawTitleText = function drawTitleText(t) {
      s.text(t, PAD, PAD * +1 + 0 * LINE, PAD * -2 + frame.width, PAD * +1 + 2 * LINE);
    };

    var drawAsciiArtText = function drawAsciiArtText(t) {
      s.text(t, PAD, PAD + +3 + 2 * LINE, PAD * -2 + frame.width, PAD * -1 + frame.height);
    };

    var drawDescriptionText = function drawDescriptionText(t) {
      s.text(t, PAD, PAD + +3 + 2 * LINE, PAD * -2 + frame.width, PAD * -6 + frame.height - (actionCount + 2) * LINE);
    };

    var drawActionsText = function drawActionsText(t) {
      s.text(t, PAD, PAD * -4 + frame.height - (actionCount + 2) * LINE, PAD * -2 + frame.width, PAD * -3 + frame.height - 2 * LINE);
    };

    var drawActionInputText = function drawActionInputText(t) {
      s.text(t, PAD, PAD * -2 + frame.height - 2 * LINE, PAD * -2 + frame.width, PAD * -1 + frame.height);
    };

    var drawNextPart = function drawNextPart(text, drawText, color, fontSize) {
      var speedMultiplier = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      s.fill(color);
      s.textSize(fontSize);

      if (charLength * speedMultiplier < text.length) {
        var _t = text.substr(0, charLength * speedMultiplier);

        drawText(_t);
        return {
          done: false
        };
      }

      drawText(text);
      charLength -= Math.floor(text.length / speedMultiplier);
      return {
        done: true
      };
    };

    var drawWaitMessage = function drawWaitMessage(timeMs, text, altText, drawText, color, fontSize) {
      var waitChars = timeMs / 1000 * charsPerSecond;

      if (charLength < waitChars) {
        var waitText = !text ? "" : !altText ? text : charLength / charsPerSecond * 1000 % 1000 < 500 ? text : altText;

        if (color) {
          s.fill(color);
        }

        if (fontSize) {
          s.textSize(fontSize);
        }

        if (waitText && drawText) {
          drawText(waitText);
        }

        return {
          done: false
        };
      }

      charLength -= waitChars;
      return {
        done: true
      };
    }; // const titleColor = s.color(
    //     255 - 60 + 30 * Math.sin((2 * Math.PI * (timeMs + 100) / 1000) / 3),
    //     255 - 60 + 30 * Math.sin((2 * Math.PI * (timeMs + 400) / 1000) / 3),
    //     255 - 60 + 30 * Math.sin((2 * Math.PI * (timeMs + 800) / 1000) / 3),
    // );
    // Use random glitch effect


    if (step.glitch && shouldGlitch) {
      s.rotate(0.25 * random());
      s.scale(1 - 0.25 * random(), 1);
      s.background(s.color(0, 150 * random(), 0));

      if (randomSlow() > 0.25) {
        s.fill(s.color(255, 255, 255));
        s.textAlign("center");
        s.textSize(12);
        var glitches = step.glitch.messages;
        s.text(glitches[Math.floor(random() * glitches.length)], PAD, PAD + LINE * 5, PAD * -2 + frame.width, PAD * -2 + frame.height);
        return {
          done: false
        };
      }
    }

    if (mode !== "step") {
      charLength = Number.MAX_SAFE_INTEGER;
    } // Skip title typing


    charLength += step.title.trim().length;
    s.textAlign("center");
    var titleColor = s.color(255, 255, 255);

    if (!drawNextPart(step.title.trim(), drawTitleText, titleColor, 14).done) {
      return {
        done: false
      };
    }

    if (!drawWaitMessage(5000, step.asciiArt, step.asciiArt, drawAsciiArtText, titleColor, 10).done) {
      return {
        done: false
      };
    }

    s.textAlign("left");

    if (!drawNextPart(step.description.trim(), drawDescriptionText, s.color(255, 255, 255), 12).done) {
      return {
        done: false
      };
    }

    if (!drawWaitMessage(1000).done) {
      return {
        done: false
      };
    }

    var actionsText = "".concat(step.actions.map(function (x) {
      return "    - ".concat(x.name, "\n");
    }).join(""));

    if (!drawNextPart(actionsText, drawActionsText, s.color(255, 255, 100), 12).done) {
      return {
        done: false
      };
    } // Blink


    if (!drawWaitMessage(3000, ">", "> |", drawActionInputText, s.color(100, 255, 100), 12).done) {
      return {
        done: false
      };
    }

    var action = step.actions[actionIndex !== null && actionIndex !== void 0 ? actionIndex : -1];
    var actionName = (_ref2 = (_action$name = action === null || action === void 0 ? void 0 : action.name) !== null && _action$name !== void 0 ? _action$name : input) !== null && _ref2 !== void 0 ? _ref2 : "";

    if (!drawNextPart("> ".concat(actionName), drawActionInputText, s.color(100, 255, 100), 14).done) {
      return {
        done: false
      };
    }

    if (!drawWaitMessage(1000).done) {
      return {
        done: false
      };
    }

    if (mode === "response" && action) {
      var _action$gameOver;

      charLength = Math.floor(timeMs / 1000 * charsPerSecond);
      s.background(s.color(25 - 25 * Math.cos(2 * Math.PI * timeMs / 1000 / 10), 0, 0));
      var actionResponse = action.description;
      var gameOver = (_action$gameOver = action.gameOver) !== null && _action$gameOver !== void 0 ? _action$gameOver : false;
      var actionColor = gameOver ? s.color(255, 100, 100) : s.color(100, 100, 255);

      if (!drawNextPart(actionResponse, drawDescriptionText, actionColor, 14).done) {
        return {
          done: false
        };
      }

      if (!drawWaitMessage(1000).done) {
        return {
          done: false
        };
      }

      if (action.gameOver == null) {
        s.textAlign("center");

        if (!drawNextPart("TO BE CONTINUED", drawActionInputText, actionColor, 14).done) {
          return {
            done: true
          };
        }
      }

      if (gameOver) {
        s.background(s.color(25 - 25 * Math.cos(2 * Math.PI * timeMs / 1000 / 10), 0, 0));

        if (!drawNextPart(gameOver, drawDescriptionText, actionColor, 14).done) {
          return {
            done: false
          };
        }

        if (!drawWaitMessage(1000).done) {
          return {
            done: false
          };
        }

        s.textAlign("center");

        if (!drawNextPart("GAME OVER", drawActionInputText, actionColor, 14).done) {
          return {
            done: true
          };
        }
      }
    }

    return {
      done: true
    };
  };
  var drawGame = function drawGame(_ref3) {
    var _gameData$story;

    var gameState = _ref3.gameState,
        gameData = _ref3.gameData,
        s = _ref3.s,
        frame = _ref3.frame,
        seed = _ref3.seed,
        timeMs = _ref3.timeMs;

    if (gameState.mode === "step" && gameState.input) {
      gameState.timeStartMs = 1;
      gameState.actionIndex = undefined;
    }

    var _gameState$stepIndex = gameState.stepIndex,
        stepIndex = _gameState$stepIndex === void 0 ? 0 : _gameState$stepIndex,
        actionIndex = gameState.actionIndex,
        _gameState$input = gameState.input,
        input = _gameState$input === void 0 ? "" : _gameState$input,
        mode = gameState.mode;
    var step = (_gameData$story = gameData.story[stepIndex || 0]) !== null && _gameData$story !== void 0 ? _gameData$story : undefined;

    if (!step) {
      return {
        done: true,
        gameState: gameState
      };
    }

    var result = drawGameStep({
      step: step,
      actionIndex: actionIndex,
      s: s,
      timeMs: timeMs,
      frame: frame,
      seed: seed,
      input: input,
      mode: mode
    });

    if (input.endsWith("\n") && input.trim()) {
      var words = input.trim().split(" ").filter(function (x) {
        return x;
      });
      var i = step.actions.findIndex(function (x) {
        return x.name.split(" ").some(function (n) {
          return words.some(function (w) {
            return w === n;
          });
        });
      });

      if (i >= 0) {
        return {
          done: false,
          gameState: _objectSpread2(_objectSpread2({}, gameState), {}, {
            input: "",
            actionIndex: i,
            mode: "response",
            timeStartMs: undefined
          })
        };
      } else {
        return {
          done: false,
          gameState: _objectSpread2(_objectSpread2({}, gameState), {}, {
            input: ""
          })
        };
      }
    }

    if (gameState.mode === "response" && result.done) {
      var _step$actions$gameOve, _step$actions, _gameState$actionInde;

      var isGameOver = (_step$actions$gameOve = (_step$actions = step.actions[(_gameState$actionInde = gameState.actionIndex) !== null && _gameState$actionInde !== void 0 ? _gameState$actionInde : -1]) === null || _step$actions === void 0 ? void 0 : _step$actions.gameOver) !== null && _step$actions$gameOve !== void 0 ? _step$actions$gameOve : true;

      if (isGameOver) {
        // Start over
        if (input) {
          return {
            done: false,
            gameState: _objectSpread2(_objectSpread2({}, gameState), {}, {
              mode: "step",
              stepIndex: 0,
              actionIndex: undefined,
              timeStartMs: undefined,
              input: ""
            })
          };
        }

        return {
          done: true,
          gameState: gameState
        };
      }

      return {
        done: false,
        gameState: _objectSpread2(_objectSpread2({}, gameState), {}, {
          mode: "step",
          stepIndex: stepIndex + 1,
          actionIndex: undefined,
          timeStartMs: undefined
        })
      };
    }

    return _objectSpread2(_objectSpread2({}, result), {}, {
      gameState: gameState
    });
  };

  function scaleByPixelRatio(input) {
    var pixelRatio = window.devicePixelRatio || 1;
    return Math.floor(input * pixelRatio);
  }

  var createEventProvider = function createEventProvider(canvas) {
    var windowSubs = [];

    var windowAddEventListener = function windowAddEventListener(name, handler, options) {
      windowSubs.push({
        name: name,
        handler: handler
      });
      return window.addEventListener(name, handler, options);
    };

    var windowEventListenersDestroy = function windowEventListenersDestroy() {
      windowSubs.forEach(function (_ref) {
        var name = _ref.name,
            handler = _ref.handler;
        window.removeEventListener(name, handler);
      });
    };

    var canvasSubs = [];

    var canvasAddEventListener = function canvasAddEventListener(name, handler, options) {
      if (!canvas) {
        return null;
      }

      canvasSubs.push({
        name: name,
        handler: handler
      });
      return canvas.addEventListener(name, handler, options);
    };

    var canvasEventListenersDestroy = function canvasEventListenersDestroy() {
      canvasSubs.forEach(function (_ref2) {
        var name = _ref2.name,
            handler = _ref2.handler;
        canvas.removeEventListener(name, handler);
      });
    };

    var clientToGamePosition = function clientToGamePosition(item, rectCached) {
      var rect = rectCached !== null && rectCached !== void 0 ? rectCached : canvas.getBoundingClientRect();
      var canvasPos = {
        x: item.clientX - rect.left,
        y: item.clientY - rect.top
      };
      var gamePos = {
        x: scaleByPixelRatio(canvasPos.x) / canvas.width,
        y: 1 - scaleByPixelRatio(canvasPos.y) / canvas.height
      };
      return gamePos;
    };

    return {
      windowAddEventListener: windowAddEventListener,
      canvasAddEventListener: canvasAddEventListener,
      tools: {
        getMouseGamePosition: function getMouseGamePosition(e) {
          return clientToGamePosition(e);
        },
        getTouchPositions: function getTouchPositions(e) {
          var rect = canvas.getBoundingClientRect();
          var pos = [];
          var touches = e.touches;

          for (var i = 0; i < touches.length; i++) {
            var touch = touches.item(i);

            if (!touch) {
              continue;
            }

            pos.push(clientToGamePosition(touch, rect));
          }

          return pos;
        }
      },
      destroy: function destroy() {
        windowEventListenersDestroy();
        canvasEventListenersDestroy();
      }
    };
  };

  var nftAdventure_nftDungeon = createNftAdventure_nftTextAdventure();
  var art_nftAdventure_nftTextAdventure = {
    key: "nft-text-adventure",
    title: nftAdventure_nftDungeon.metadata.name,
    description: nftAdventure_nftDungeon.metadata.description,
    artist: nftAdventure_nftDungeon.metadata.author,
    canSetSeed: false,
    getTokenDescription: function getTokenDescription(seed) {
      var _step$title2, _action$name;

      var _seed$split$map = seed.split(":").map(function (x) {
        return parseInt(x, 10);
      }),
          _seed$split$map2 = _slicedToArray(_seed$split$map, 2),
          stepIndex = _seed$split$map2[0],
          actionIndex = _seed$split$map2[1];

      var step = nftAdventure_nftDungeon.story[stepIndex];
      var action = step === null || step === void 0 ? void 0 : step.actions[actionIndex];

      if (!action) {
        var _step$title;

        return "".concat(stepIndex, " - ").concat((_step$title = step === null || step === void 0 ? void 0 : step.title) !== null && _step$title !== void 0 ? _step$title : "");
      }

      return "".concat(stepIndex, ":").concat(actionIndex, " - ").concat((_step$title2 = step === null || step === void 0 ? void 0 : step.title) !== null && _step$title2 !== void 0 ? _step$title2 : "", " > ").concat((_action$name = action === null || action === void 0 ? void 0 : action.name) !== null && _action$name !== void 0 ? _action$name : "");
    },
    // openSea: {
    //     tokenAddress: `0x495f947276749ce646f68ac8c248420045cb7b5e`,
    //     tokenId: `91242641486941084018191434774360347389366801368112854311223385694785434025985`,
    // },
    renderArt: function renderArt(hostElement) {
      var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "This is my hash!";
      var recorder = arguments.length > 2 ? arguments[2] : undefined;
      var createP5 = arguments.length > 3 ? arguments[3] : undefined;

      // const { a, b, c } = { a: 57, b: 23, c: 15 };
      createRandomGenerator(seed);
   // const { a, b, c } = { a: 1 + Math.floor(57 * random()), b: 1 + Math.floor(213 * random()), c: 1 + Math.floor(115 * random()) };
      // const { cr, cg, cb, ca } = { cr: Math.floor(25 + 230 * random()), cg: Math.floor(25 + 230 * random()), cb: Math.floor(25 + 230 * random()), ca: Math.floor(25 + 25 * random()) };


      var TARGET_SIZE = 300;
      var SMALL_SIZE = 300;
      var size = window.innerWidth > TARGET_SIZE && window.innerHeight > TARGET_SIZE ? TARGET_SIZE : SMALL_SIZE;
      var canvas = null;
      var wasRecording = false;
      var eventProvider = null;

      var _seed$split$map3 = seed.split(":").map(function (x) {
        return parseInt(x, 10);
      }),
          _seed$split$map4 = _slicedToArray(_seed$split$map3, 2),
          stepIndexInit = _seed$split$map4[0],
          actionIndexInit = _seed$split$map4[1];

      var now = function now() {
        return recorder ? recorder.timeProvider.now() : Date.now();
      };

      var gameState = {
        timeStart: now(),
        stepIndex: stepIndexInit,
        actionIndex: actionIndexInit,
        input: "",
        isRespondingToInput: false,
        mode: "step"
      };
      return createP5(function (s) {
        s.setup = function () {
          console.log("renderArt:createP5:s.setup");
          var result = s.createCanvas(size, size);
          var canvasId = "".concat(Math.random());
          result.id(canvasId);
          canvas = document.getElementById(canvasId);
          eventProvider = createEventProvider(canvas);
          eventProvider.windowAddEventListener("keydown", function (x) {
            if (x.key.toLowerCase() === "backspace") {
              gameState.input = gameState.input.substr(0, gameState.input.length - 1);
            } else if (x.key.toLowerCase() === "enter") {
              gameState.input += "\n";
            } else if (x.key.match(/^[A-Za-z0-9 ]$/)) {
              gameState.input = gameState.input.trimStart() + x.key;
            }

            console.log("keypress", {
              x: x,
              input: gameState.input
            });
          });
        };

        s.draw = function () {
          var _recorder$isRecording, _gameState$timeStartM;

          // console.log(`renderArt:createP5:s.draw`);
          if (recorder !== null && recorder !== void 0 && recorder.isRecording() && !wasRecording) {
            gameState.timeStartMs = recorder.timeProvider.now();
          }

          wasRecording = (_recorder$isRecording = recorder === null || recorder === void 0 ? void 0 : recorder.isRecording()) !== null && _recorder$isRecording !== void 0 ? _recorder$isRecording : false; // if (isDone){ return; }
          // if (recorder?.isWaitingForFrame() && canvas) {
          //     console.log(`game.update waitingForFrame - addFrame`, {});
          //     (async () => await recorder.getRecorder().addFrame(canvas))();
          //     return;
          // }

          var timeStart = (_gameState$timeStartM = gameState.timeStartMs) !== null && _gameState$timeStartM !== void 0 ? _gameState$timeStartM : now();
          var timeMs = now() - timeStart;
          var result = drawGame({
            frame: {
              width: size,
              height: size
            },
            s: s,
            gameData: nftAdventure_nftDungeon,
            gameState: gameState,
            seed: seed,
            timeMs: timeMs
          });
          gameState = result.gameState;

          if (!gameState.timeStartMs) {
            gameState.timeStartMs = now();
          }

          if (result.done) {
            return;
          }

          if (recorder !== null && recorder !== void 0 && recorder.isWaitingForFrame() && canvas) {
            console.log("game.update waitingForFrame - addFrame", {});

            _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return recorder.getRecorder().addFrame(canvas);

                    case 2:
                      return _context.abrupt("return", _context.sent);

                    case 3:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }))();
          }
        };
      }, hostElement);
    }
  };

  exports.art_nftAdventure_nftTextAdventure = art_nftAdventure_nftTextAdventure;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}(window));

    
var seedMatch = document.location.search.match(/seed=([^;])/) || document.location.search.match(/tokenId=([^;])/);
var seed = seedMatch && seedMatch[1] || '0';

var createP5 = function(s,host){
    return new p5(s,host);
};

window.art_nftAdventure_nftTextAdventure.renderArt(
    document.getElementById('host'),
    seed,
    null,
    createP5
)
    </script>

</body>
</html>