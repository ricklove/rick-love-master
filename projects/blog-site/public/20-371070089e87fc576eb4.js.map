{"version":3,"sources":["webpack:///D:/Projects/rick-love-master/code/doodle/doodle-view.tsx"],"names":["emptyDrawing","width","height","segments","DoodleView","props","useState","doodle","setDoodle","DoodleSvg","style","color","backgroundColor","drawing","onChange","createLinePath","segment","points","length","x","y","slice","map","p","join","scale","setSegment","segmentClientStart","useRef","clientX","clientY","divHost","onIgnore","e","preventDefault","stopPropagation","cancelBubble","returnValue","onPressIn","event","pos","div","current","rect","getBoundingClientRect","Math","floor","onPressOut","s","onClientMove","onMove","useEffect","onTouchStart","touches","onTouchMove","addEventListener","passive","removeEventListener","ref","viewBox","preserveAspectRatio","xmlns","d","stroke","fill"],"mappings":"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","file":"20-371070089e87fc576eb4.js","sourcesContent":["/* eslint-disable jsx-a11y/no-static-element-interactions */\r\nimport React, { useState, useRef, useEffect } from 'react';\r\n\r\ntype DoodleDrawing = {\r\n    width: number;\r\n    height: number;\r\n    segments: DoodleSegment[];\r\n};\r\ntype DoodleSegment = {\r\n    points: { x: number, y: number }[];\r\n};\r\n\r\n// const sampleDrawing: DoodleDrawing = {\r\n//     width: 128,\r\n//     height: 128,\r\n//     segments: [{\r\n//         points: [\r\n//             { x: 10, y: 10 },\r\n//             { x: 50, y: 10 },\r\n//             { x: 50, y: 50 },\r\n//             { x: 10, y: 50 },\r\n//             { x: 10, y: 10 },\r\n//         ],\r\n//     }],\r\n// };\r\n\r\nconst emptyDrawing: DoodleDrawing = {\r\n    width: 128,\r\n    height: 128,\r\n    segments: [],\r\n};\r\n\r\nexport const DoodleView = (props: {}) => {\r\n\r\n    const [doodle, setDoodle] = useState(emptyDrawing);\r\n\r\n    return (\r\n        <>\r\n            <DoodleSvg style={{ width: 256, height: 256, color: `#FFFFFF`, backgroundColor: `#000000` }} drawing={doodle} onChange={setDoodle} />\r\n        </>\r\n    );\r\n};\r\n\r\n// const createBezierCurvePath = (segment: DoodleSegment) => {\r\n//     const delta1 = {\r\n//         x: segment.points[2].x - segment.points[1].x,\r\n//         y: segment.points[2].y - segment.points[1].y,\r\n//     };\r\n//     const controlPoint = {\r\n//         x: segment.points[1].x - delta1.x * 0.5,\r\n//         y: segment.points[1].y - delta1.y * 0.5,\r\n//     };\r\n//     return `M${segment.points[0].x} ${segment.points[0].y} Q${controlPoint.x} ${controlPoint.y} ${segment.points[1].x} ${segment.points[1].y}T${segment.points.slice(2, -1).map(p => `${p.x} ${p.y}`).join(` `)}`;\r\n// };\r\n\r\nconst createLinePath = (segment: DoodleSegment) => {\r\n    if (segment.points.length <= 0) { return ``; }\r\n    if (segment.points.length === 1) { return `M${segment.points[0].x} ${segment.points[0].y} L${segment.points[0].x} ${segment.points[0].y}`; }\r\n\r\n    return `M${segment.points[0].x} ${segment.points[0].y} L${segment.points.slice(1).map(p => `${p.x} ${p.y}`).join(` `)}`;\r\n};\r\n\r\nconst DoodleSvg = (props: { style: { width: number, height: number, color: string, backgroundColor: string }, drawing: DoodleDrawing, onChange: (drawing: DoodleDrawing) => void }) => {\r\n    const { style, drawing, onChange } = props;\r\n    const scale = style.width / drawing.width;\r\n\r\n    const [segment, setSegment] = useState(null as null | DoodleSegment);\r\n    const segmentClientStart = useRef({ clientX: 0, clientY: 0, x: 0, y: 0 });\r\n    const divHost = useRef(null as null | HTMLDivElement);\r\n\r\n    const onIgnore = (e: Event) => {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        e.cancelBubble = true;\r\n        e.returnValue = false;\r\n        return false;\r\n    };\r\n\r\n    const onPressIn = (event: (Event) & { clientX?: number, clientY?: number }, pos?: { clientX: number, clientY: number }) => {\r\n        const div = divHost.current;\r\n        if (!div) { return onIgnore(event); }\r\n\r\n        const rect = div.getBoundingClientRect();\r\n\r\n        setSegment({ points: [] });\r\n\r\n        const p = {\r\n            clientX: pos?.clientX ?? event.clientX ?? 0,\r\n            clientY: pos?.clientY ?? event.clientY ?? 0,\r\n        };\r\n\r\n        segmentClientStart.current = {\r\n            clientX: p.clientX,\r\n            clientY: p.clientY,\r\n            x: Math.floor((p.clientX - rect.x) / scale),\r\n            y: Math.floor((p.clientY - rect.y) / scale),\r\n        };\r\n\r\n        return onIgnore(event);\r\n    };\r\n    const onPressOut = (event: Event) => {\r\n        const s = segment;\r\n        if (!s) { return onIgnore(event); }\r\n\r\n        onChange({\r\n            ...drawing,\r\n            segments: [...drawing.segments, s],\r\n        });\r\n        setSegment(null);\r\n\r\n        return onIgnore(event);\r\n    };\r\n    const onMove = (pos: { x: number, y: number }) => {\r\n        setSegment(s => {\r\n            if (!s) { return null; }\r\n            return { points: [...s.points, pos] };\r\n        });\r\n    };\r\n    const onClientMove = (event: (Event) & { clientX?: number, clientY?: number }, pos?: { clientX: number, clientY: number }) => {\r\n        const p = {\r\n            clientX: pos?.clientX ?? event.clientX ?? 0,\r\n            clientY: pos?.clientY ?? event.clientY ?? 0,\r\n        };\r\n        const dPos = {\r\n            x: Math.floor((p.clientX - segmentClientStart.current.clientX) / scale) + segmentClientStart.current.x,\r\n            y: Math.floor((p.clientY - segmentClientStart.current.clientY) / scale) + segmentClientStart.current.y,\r\n        };\r\n\r\n        onMove(dPos);\r\n        return onIgnore(event);\r\n    };\r\n\r\n    useEffect(() => {\r\n        const div = divHost.current;\r\n        if (!div) { return () => { }; }\r\n\r\n        const onTouchStart = (x: Event) => onPressIn(x, (x as TouchEvent).touches[0]);\r\n        const onTouchMove = (x: Event) => onClientMove(x, (x as TouchEvent).touches[0]);\r\n\r\n        div.addEventListener(`mouseDown`, onPressIn, { passive: false });\r\n        div.addEventListener(`onTouchStart`, onTouchStart, { passive: false });\r\n        div.addEventListener(`onMouseUp`, onPressOut, { passive: false });\r\n        div.addEventListener(`onTouchEnd`, onPressOut, { passive: false });\r\n        div.addEventListener(`onMouseLeave`, onPressOut, { passive: false });\r\n        div.addEventListener(`onTouchEndCapture`, onPressOut, { passive: false });\r\n        div.addEventListener(`onMouseMove`, onClientMove, { passive: false });\r\n        div.addEventListener(`onTouchMove`, onTouchMove, { passive: false });\r\n\r\n        return () => {\r\n            div.removeEventListener(`mouseDown`, onPressIn);\r\n            div.removeEventListener(`onTouchStart`, onTouchStart);\r\n            div.removeEventListener(`onMouseUp`, onPressOut);\r\n            div.removeEventListener(`onTouchEnd`, onPressOut);\r\n            div.removeEventListener(`onMouseLeave`, onPressOut);\r\n            div.removeEventListener(`onTouchEndCapture`, onPressOut);\r\n            div.removeEventListener(`onMouseMove`, onClientMove);\r\n            div.removeEventListener(`onTouchMove`, onTouchMove);\r\n        };\r\n    }, [divHost.current]);\r\n\r\n    return (\r\n        <div ref={divHost} style={{ width: style.width, height: style.height, backgroundColor: style.backgroundColor }}\r\n        // onMouseDown={onPressIn}\r\n        // onMouseUp={onPressOut}\r\n        // onMouseMove={onClientMove}\r\n        // onMouseLeave={onPressOut}\r\n        // onTouchStart={x => onPressIn(x, x.touches[0])}\r\n        // onTouchEnd={onPressOut}\r\n        // onTouchCancel={onPressOut}\r\n        // onTouchMove={x => onClientMove(x, x.touches[0])}\r\n        // onTouchEndCapture={onPressOut}\r\n        >\r\n            <svg style={{ width: style.width, height: style.height }} viewBox={`0 0 ${drawing.width} ${drawing.height}`} preserveAspectRatio='none' xmlns='http://www.w3.org/2000/svg'>\r\n                {drawing.segments.map(x => (\r\n                    <path d={createLinePath(x)} stroke={style.color} fill='transparent' />\r\n                ))}\r\n                {segment && (\r\n                    <path d={createLinePath(segment)} stroke={style.color} fill='transparent' />\r\n                )}\r\n            </svg>\r\n        </div>\r\n    );\r\n};\r\n"],"sourceRoot":""}