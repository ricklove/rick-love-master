{"version":3,"sources":["webpack:///D:/Projects/rick-love-master/code/websockets-api/client/config.ts","webpack:///D:/Projects/rick-love-master/code/websockets-api/client/websocket-client-test-view.tsx","webpack:///D:/Projects/rick-love-master/code/websockets-api/client/websocket-client.ts"],"names":["websocketsApiConfig","key","Date","now","Math","random","WebsocketClientTestView","props","useState","messages","setMessages","events","setEvents","send","useRef","useEffect","config","connection","websocketsApiUrl","connect","subscribable","createSubscribable","subscribableEvents","createSocket","socket","WebSocket","addEventListener","event","activeSocket","onStateChange","connectionStatus","messageContainer","message","JSON","stringify","close","reconnect","error","m","parse","data","setTimeout","readyState","OPEN","AppError","subscribeMessages","subscribe","subscribeConnectionEvents","current","unsubMessages","s","receivedAtTimestamp","unsubEvents","unsubscribe","messageText","setMessageText","sendMessage","text","timestamp","senderKey","style","padding","whiteSpace","fontSize","map","x","i","flexDirection","alignItems","flex","paddingRight","value","onChange","keyboardType","autoCompleteType","onBlur","onSubmitEditing","onPress"],"mappings":"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","file":"31-ea74b9a906b2f295e262.js","sourcesContent":["export const websocketsApiConfig = {\r\n    websocketsApiUrl: `wss://p4w1a7ysk8.execute-api.us-east-1.amazonaws.com/prod`,\r\n};\r\n","/* eslint-disable react/no-array-index-key */\r\nimport React, { useRef, useState, useEffect } from 'react';\r\nimport { View, Text, TouchableOpacity, TextInput } from 'react-native-lite';\r\nimport { createWebsocketClient } from './websocket-client';\r\nimport { websocketsApiConfig } from './config';\r\nimport { WebsocketConnectionEvent } from './types';\r\n\r\nconst key = `${Date.now()}${Math.random()}`;\r\n\r\nexport const WebsocketClientTestView = (props: {}) => {\r\n\r\n    type TestMessage = {\r\n        text?: string;\r\n        timestamp: number;\r\n        senderKey: string;\r\n    };\r\n    const [messages, setMessages] = useState([] as (TestMessage & { receivedAtTimestamp: number })[]);\r\n    const [events, setEvents] = useState([] as WebsocketConnectionEvent[]);\r\n    const send = useRef(null as null | ((message: TestMessage) => void));\r\n\r\n\r\n    useEffect(() => {\r\n        const connection = createWebsocketClient({ websocketsApiUrl: websocketsApiConfig.websocketsApiUrl })\r\n            .connect<TestMessage>({ key: `test` });\r\n\r\n        send.current = connection.send;\r\n\r\n        const unsubMessages = connection.subscribeMessages(message => {\r\n\r\n            setMessages(s => [...s, { ...message, receivedAtTimestamp: Date.now() }]);\r\n        });\r\n        const unsubEvents = connection.subscribeConnectionEvents(event => {\r\n            setEvents(s => [...s, event]);\r\n        });\r\n        return () => {\r\n            send.current = null;\r\n            unsubMessages.unsubscribe();\r\n            unsubEvents.unsubscribe();\r\n        };\r\n    }, []);\r\n\r\n    const [messageText, setMessageText] = useState(``);\r\n    const sendMessage = () => {\r\n        if (!send.current) { return; }\r\n        send.current?.({ text: messageText, timestamp: Date.now(), senderKey: key });\r\n        setMessageText(``);\r\n    };\r\n\r\n    return (\r\n        <View style={{ padding: 4 }}>\r\n            <View style={{ padding: 4 }}>\r\n\r\n                <Text style={{ whiteSpace: `pre-wrap`, fontSize: 18 }}>Events</Text>\r\n                {events.map((x, i) => (\r\n                    <Text key={i} style={{ whiteSpace: `pre-wrap`, fontSize: 14 }}>{JSON.stringify(x)}</Text>\r\n                ))}\r\n            </View>\r\n            <View style={{ padding: 4 }}>\r\n                <Text style={{ whiteSpace: `pre-wrap`, fontSize: 18 }}>Messages</Text>\r\n                {messages.map((x, i) => (\r\n                    <Text key={i} style={{ whiteSpace: `pre-wrap`, fontSize: 14 }}>{`${x.timestamp} ${x.receivedAtTimestamp - x.timestamp}: ${x.text ?? JSON.stringify(x)}`}</Text>\r\n                ))}\r\n            </View>\r\n            <View style={{ padding: 4 }}>\r\n                <Text style={{ whiteSpace: `pre-wrap`, fontSize: 18 }}>Send Message</Text>\r\n                <View style={{ flexDirection: `row`, alignItems: `center` }}>\r\n                    <View style={{ flex: 1, paddingRight: 4 }}>\r\n                        <TextInput style={{ fontSize: 16 }} value={messageText} onChange={setMessageText} keyboardType='default' autoCompleteType='off' onBlur={sendMessage} onSubmitEditing={sendMessage} />\r\n                    </View>\r\n                    <TouchableOpacity onPress={sendMessage} >\r\n                        <Text style={{ whiteSpace: `pre-wrap`, fontSize: 18 }}>Send</Text>\r\n                    </TouchableOpacity>\r\n                </View>\r\n            </View>\r\n        </View>\r\n    );\r\n};\r\n","import { createSubscribable } from 'utils/subscribable';\r\nimport { AppError } from 'utils/error';\r\nimport { WebsocketApi, WebsocketConnectionEvent, WebsocketConnectionData } from './types';\r\n\r\nexport const createWebsocketClient = (config: { websocketsApiUrl: string }): WebsocketApi => {\r\n\r\n    const api: WebsocketApi = {\r\n        connect: <T>({ key }: WebsocketConnectionData) => {\r\n            // With this implementation, the server simply echos all messages to all clients\r\n            // The client will filter those messages client-side with the key\r\n            // NOTE: When the server filters via keys (providing privacy), this will continue to work without changes\r\n\r\n            type MessageContainer = {\r\n                message: T | null;\r\n                key: string;\r\n            };\r\n\r\n            const subscribable = createSubscribable<T>();\r\n            const subscribableEvents = createSubscribable<WebsocketConnectionEvent>();\r\n\r\n            // Connect to websocket (and reconnect, etc.)\r\n            const createSocket = () => {\r\n                const socket = new WebSocket(`${config.websocketsApiUrl}`);\r\n\r\n                // Connection opened\r\n                socket.addEventListener(`open`, (event) => {\r\n                    if (socket !== activeSocket) {\r\n                        socket.close();\r\n                        return;\r\n                    }\r\n\r\n                    subscribableEvents.onStateChange({ connectionStatus: `opened` });\r\n\r\n                    // Send a key message\r\n                    const messageContainer: MessageContainer = {\r\n                        message: null,\r\n                        key,\r\n                    };\r\n                    socket.send(JSON.stringify(messageContainer));\r\n\r\n                });\r\n                socket.addEventListener(`close`, (event) => {\r\n                    if (socket !== activeSocket) {\r\n                        socket.close();\r\n                        return;\r\n                    }\r\n\r\n                    subscribableEvents.onStateChange({ connectionStatus: `closed` });\r\n                    reconnect();\r\n                });\r\n                socket.addEventListener(`error`, (event) => {\r\n                    if (socket !== activeSocket) {\r\n                        socket.close();\r\n                        return;\r\n                    }\r\n\r\n                    subscribableEvents.onStateChange({ connectionStatus: `error`, error: { message: `Websocket Error`, error: event } });\r\n                    reconnect();\r\n                });\r\n\r\n                // Listen for messages\r\n                socket.addEventListener(`message`, (event) => {\r\n                    if (socket !== activeSocket) {\r\n                        socket.close();\r\n                        return;\r\n                    }\r\n\r\n                    const m = JSON.parse(event.data) as MessageContainer;\r\n                    if (m.key !== key || !m.message) { return; }\r\n                    subscribable.onStateChange(m.message);\r\n                });\r\n\r\n                return socket;\r\n            };\r\n\r\n            let activeSocket: WebSocket = createSocket();\r\n            const reconnect = () => {\r\n                setTimeout(() => {\r\n                    activeSocket = createSocket();\r\n                }, 50);\r\n            };\r\n\r\n            // Send Messages\r\n            const send = (message: T) => {\r\n                if (activeSocket.readyState !== WebSocket.OPEN) {\r\n                    throw new AppError(`Websocket is not open`);\r\n                }\r\n                const messageContainer: MessageContainer = {\r\n                    message,\r\n                    key,\r\n                };\r\n                activeSocket.send(JSON.stringify(messageContainer));\r\n            };\r\n\r\n            return {\r\n                send,\r\n                subscribeMessages: subscribable.subscribe,\r\n                subscribeConnectionEvents: subscribableEvents.subscribe,\r\n            };\r\n        },\r\n    };\r\n\r\n    return api;\r\n};\r\n"],"sourceRoot":""}