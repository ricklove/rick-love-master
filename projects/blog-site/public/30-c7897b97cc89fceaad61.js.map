{"version":3,"sources":["webpack:///D:/Projects/rick-love-master/code/websockets-api/client/config.ts","webpack:///D:/Projects/rick-love-master/code/websockets-api/client/websocket-client-test-view.tsx","webpack:///D:/Projects/rick-love-master/code/websockets-api/client/websocket-client.ts"],"names":["websocketsApiConfig","WebsocketClientTestView","props","useState","messages","setMessages","events","setEvents","send","useRef","useEffect","config","connection","websocketsApiUrl","connect","key","subscribable","createSubscribable","subscribableEvents","socket","WebSocket","addEventListener","event","onStateChange","connectionStatus","messageContainer","message","JSON","stringify","setTimeout","error","m","parse","data","readyState","OPEN","AppError","subscribeMessages","subscribe","subscribeConnectionEvents","current","unsubMessages","s","unsubEvents","unsubscribe","messageText","setMessageText","style","padding","whiteSpace","fontSize","map","x","i","text","flexDirection","alignItems","flex","paddingRight","value","onChange","keyboardType","autoCompleteType","onPress"],"mappings":"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","file":"30-c7897b97cc89fceaad61.js","sourcesContent":["export const websocketsApiConfig = {\r\n    websocketsApiUrl: `wss://p4w1a7ysk8.execute-api.us-east-1.amazonaws.com/prod`,\r\n};\r\n","/* eslint-disable react/no-array-index-key */\r\nimport React, { useRef, useState, useEffect } from 'react';\r\nimport { View, Text, TouchableOpacity, TextInput } from 'react-native-lite';\r\nimport { createWebsocketClient } from './websocket-client';\r\nimport { websocketsApiConfig } from './config';\r\nimport { WebsocketConnectionEvent } from './types';\r\n\r\nexport const WebsocketClientTestView = (props: {}) => {\r\n\r\n    type TestMessage = {\r\n        text: string;\r\n    };\r\n    const [messages, setMessages] = useState([] as TestMessage[]);\r\n    const [events, setEvents] = useState([] as WebsocketConnectionEvent[]);\r\n    const send = useRef(null as null | ((message: TestMessage) => void));\r\n\r\n\r\n    useEffect(() => {\r\n        const connection = createWebsocketClient({ websocketsApiUrl: websocketsApiConfig.websocketsApiUrl })\r\n            .connect<TestMessage>({ key: `test` });\r\n\r\n        send.current = connection.send;\r\n\r\n        const unsubMessages = connection.subscribeMessages(message => {\r\n            setMessages(s => [...s, message]);\r\n        });\r\n        const unsubEvents = connection.subscribeConnectionEvents(event => {\r\n            setEvents(s => [...s, event]);\r\n        });\r\n        return () => {\r\n            send.current = null;\r\n            unsubMessages.unsubscribe();\r\n            unsubEvents.unsubscribe();\r\n        };\r\n    }, []);\r\n\r\n    const [messageText, setMessageText] = useState(``);\r\n    const sendMessage = () => {\r\n        if (!send.current) { return; }\r\n        send.current?.({ text: messageText });\r\n        setMessageText(``);\r\n    };\r\n\r\n    return (\r\n        <View style={{ padding: 4 }}>\r\n            <View style={{ padding: 4 }}>\r\n\r\n                <Text style={{ whiteSpace: `pre-wrap`, fontSize: 18 }}>Events</Text>\r\n                {events.map((x, i) => (\r\n                    <Text key={i} style={{ whiteSpace: `pre-wrap`, fontSize: 14 }}>{JSON.stringify(x)}</Text>\r\n                ))}\r\n            </View>\r\n            <View style={{ padding: 4 }}>\r\n                <Text style={{ whiteSpace: `pre-wrap`, fontSize: 18 }}>Messages</Text>\r\n                {messages.map((x, i) => (\r\n                    <Text key={i} style={{ whiteSpace: `pre-wrap`, fontSize: 14 }}>{x.text}</Text>\r\n                ))}\r\n            </View>\r\n            <View style={{ padding: 4 }}>\r\n                <Text style={{ whiteSpace: `pre-wrap`, fontSize: 18 }}>Send Message</Text>\r\n                <View style={{ flexDirection: `row`, alignItems: `center` }}>\r\n                    <View style={{ flex: 1, paddingRight: 4 }}>\r\n                        <TextInput value={messageText} onChange={setMessageText} keyboardType='default' autoCompleteType='off' />\r\n                    </View>\r\n                    <TouchableOpacity onPress={sendMessage} >\r\n                        <Text style={{ whiteSpace: `pre-wrap`, fontSize: 18 }}>Send</Text>\r\n                    </TouchableOpacity>\r\n                </View>\r\n            </View>\r\n        </View>\r\n    );\r\n};\r\n","import { createSubscribable } from 'utils/subscribable';\r\nimport { AppError } from 'utils/error';\r\nimport { WebsocketApi, WebsocketConnectionEvent, WebsocketConnectionData } from './types';\r\n\r\nexport const createWebsocketClient = (config: { websocketsApiUrl: string }): WebsocketApi => {\r\n\r\n    const api: WebsocketApi = {\r\n        connect: <T>({ key }: WebsocketConnectionData) => {\r\n            // With this implementation, the server simply echos all messages to all clients\r\n            // The client will filter those messages client-side with the key\r\n            // NOTE: When the server filters via keys (providing privacy), this will continue to work without changes\r\n\r\n            type MessageContainer = {\r\n                message: T | null;\r\n                key: string;\r\n            };\r\n\r\n            const subscribable = createSubscribable<T>();\r\n            const subscribableEvents = createSubscribable<WebsocketConnectionEvent>();\r\n\r\n            // Connect to websocket (and reconnect, etc.)\r\n            let socket = new WebSocket(`${config.websocketsApiUrl}`);\r\n\r\n            // Connection opened\r\n            socket.addEventListener(`open`, (event) => {\r\n                subscribableEvents.onStateChange({ connectionStatus: `opened` });\r\n\r\n                // Send a key message\r\n                const messageContainer: MessageContainer = {\r\n                    message: null,\r\n                    key,\r\n                };\r\n                socket.send(JSON.stringify(messageContainer));\r\n\r\n            });\r\n            socket.addEventListener(`close`, (event) => {\r\n                subscribableEvents.onStateChange({ connectionStatus: `closed` });\r\n\r\n                // Try to reconnect\r\n                setTimeout(() => {\r\n                    socket = new WebSocket(config.websocketsApiUrl);\r\n                }, 50);\r\n            });\r\n            socket.addEventListener(`error`, (event) => {\r\n                subscribableEvents.onStateChange({ connectionStatus: `error`, error: { message: `Websocket Error`, error: event } });\r\n\r\n                // Try to reconnect\r\n                setTimeout(() => {\r\n                    socket = new WebSocket(config.websocketsApiUrl);\r\n                }, 50);\r\n            });\r\n\r\n            // Listen for messages\r\n            socket.addEventListener(`message`, (event) => {\r\n                const m = JSON.parse(event.data) as MessageContainer;\r\n                if (m.key !== key || !m.message) { return; }\r\n                subscribable.onStateChange(m.message);\r\n            });\r\n\r\n            // Send Messages\r\n            const send = (message: T) => {\r\n                if (socket.readyState !== WebSocket.OPEN) {\r\n                    throw new AppError(`Websocket is not open`);\r\n                }\r\n                const messageContainer: MessageContainer = {\r\n                    message,\r\n                    key,\r\n                };\r\n                socket.send(JSON.stringify(messageContainer));\r\n            };\r\n\r\n            return {\r\n                send,\r\n                subscribeMessages: subscribable.subscribe,\r\n                subscribeConnectionEvents: subscribableEvents.subscribe,\r\n            };\r\n        },\r\n    };\r\n\r\n    return api;\r\n};\r\n"],"sourceRoot":""}