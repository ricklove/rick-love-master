{"version":3,"sources":["webpack:///D:/Projects/rick-love-master/code/art/artwork/art-121-helpers.ts","webpack:///D:/Projects/rick-love-master/code/art/artwork/art-121.tsx"],"names":["parseTokenId_art121","tokenId","tokenTimestampValue","Number","parseInt","substr","length","tokenCounterValue","console","log","isFinite","tokenCounter","timestampSecs","targetSecs","Math","floor","Date","getTime","timeDeltaSecs","abs","art_121","key","title","description","artist","getTokenDescription","tokenData","renderArt","hostElement","random","createRandomGenerator","cr","cg","cb","ca","tick","p5","s","setup","createCanvas","draw","background","drawClock","index","clockRadius","units","value","perUnit","iHalf","sin","PI","isFront","xZeroValue","i","correctRatioRaw","zRotation","cos","angleOffset","x","y","isFrontValue","sign","colorKey","alphaShift","lowAlpha","ceil","noFill","stroke","color","strokeWeight","line","translate","defaultDelta","now","tokenTimeDeltaSecs","delta","e","year","month","day","hour","minute","second","iTick"],"mappings":"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","file":"18-367ce1b3f50fc2f0b649.js","sourcesContent":["export const parseTokenId_art121 = (tokenId: string) => {\r\n    const tokenTimestampValue = Number.parseInt(tokenId.substr(0, tokenId.length - 6), 10);\r\n    const tokenCounterValue = Number.parseInt(tokenId.substr(tokenId.length - 6), 10);\r\n    console.log(`parseTokenId_art121`, { tokenId, tokenTimestampValue, tokenCounterValue });\r\n\r\n    if (!Number.isFinite(tokenTimestampValue)) { return null; }\r\n    if (!Number.isFinite(tokenCounterValue)) { return null; }\r\n\r\n    const tokenCounter = tokenCounterValue;\r\n    const timestampSecs = tokenTimestampValue;\r\n    const targetSecs = Math.floor(new Date(`2021-01-21 21:21:21Z`).getTime()) / 1000;\r\n    const timeDeltaSecs = Math.abs(targetSecs - timestampSecs);\r\n    return {\r\n        tokenId,\r\n        tokenCounter,\r\n        timestampSecs,\r\n        targetSecs,\r\n        timeDeltaSecs,\r\n    };\r\n};\r\n","/* eslint-disable new-cap */\r\n/* eslint-disable no-new */\r\nimport p5 from 'p5';\r\nimport { createRandomGenerator } from '../rando';\r\nimport { parseTokenId_art121 } from './art-121-helpers';\r\nimport { ArtWork } from '../artwork-type';\r\n\r\nexport const art_121: ArtWork = {\r\n    key: `121`,\r\n    title: `1/21/21 21:21:21`,\r\n    description: `This exact time pattern will occur only once in our human timeline. This NFT crypto art will attempt to capture that time to the precise second and embed it in the distributed blockchain forever. \r\n    \r\nHowever the exact outcome cannot be controlled: \r\n\r\nThe color scheme is generated from the token hash.\r\n\r\nEven more difficult to predict - the block mining timestamp since 1/21/21 21:21:21 UTC controls the behavior of the clocks:\r\n\r\nYear\r\nMonth\r\nDay\r\nHour\r\nMinute\r\nSecond\r\n\r\nIf this is mined at the exact second, perfect stability will be achieved.\r\n\r\nThis is all up to whatever timing occurs on the blockchain when these NFTs are mined by the collectors.\r\n\r\nCan we obtain the exact precision?\r\n`,\r\n    artist: `Rick Love`,\r\n    getTokenDescription: (tokenId: string) => {\r\n        const tokenData = parseTokenId_art121(tokenId);\r\n        if (!tokenData) { return null; }\r\n\r\n        return `${tokenData.timeDeltaSecs} Seconds from 1/21/21 21:21:21 (#${tokenData.tokenCounter})`;\r\n    },\r\n    renderArt: (hostElement: HTMLElement, tokenId: string) => {\r\n        // const { a, b, c } = { a: 57, b: 23, c: 15 };\r\n\r\n\r\n        const { random } = createRandomGenerator(tokenId);\r\n        const { a, b, c } = { a: 1 + Math.floor(57 * random()), b: 1 + Math.floor(213 * random()), c: 1 + Math.floor(115 * random()) };\r\n        const { cr, cg, cb, ca } = { cr: Math.floor(25 + 230 * random()), cg: Math.floor(25 + 230 * random()), cb: Math.floor(25 + 230 * random()), ca: Math.floor(25 + 25 * random()) };\r\n\r\n        let tick = 0;\r\n\r\n        const tokenData = parseTokenId_art121(tokenId);\r\n\r\n        return new p5((s: p5) => {\r\n            s.setup = () => {\r\n                s.createCanvas(350, 350);\r\n            };\r\n            s.draw = () => {\r\n                s.background(0);\r\n\r\n                const drawClock = (index: number, clockRadius: number, units: number, value: number) => {\r\n\r\n                    const perUnit = 1 / units;\r\n                    const d = 0.8 * clockRadius * Math.sin(Math.PI * 2 * perUnit);\r\n\r\n                    for (let iHalf = 0; iHalf <= 1; iHalf++) {\r\n                        const isFront = iHalf === 1;\r\n                        let xZeroValue = 0;\r\n                        for (let i = 0; i < units; i++) {\r\n\r\n\r\n                            const errorRatio = (0.5 - Math.abs((value * perUnit) - 0.5)) * 2;\r\n                            const correctRatioRaw = 1 - errorRatio;\r\n                            // const correctRatio = correctRatioRaw * ((tick * 0.121 * correctRatioRaw) % 2 - 1);\r\n                            const zRotation = Math.cos((tick * 0.0121 * correctRatioRaw + index * 0.25));\r\n                            const angleOffset = -0.25 + value * perUnit;\r\n\r\n                            const x = zRotation * clockRadius * Math.cos(Math.PI * 2 * (angleOffset - i * perUnit));\r\n                            const y = clockRadius * Math.sin(Math.PI * 2 * (angleOffset - i * perUnit));\r\n\r\n                            if (i === 0) {\r\n                                xZeroValue = x;\r\n                            }\r\n\r\n                            const isFrontValue = (value === 0 && index % 2 === 0 ? -1 : 1) * Math.sign(xZeroValue) === Math.sign(x);\r\n                            // const isFrontValue = Math.sign(xZeroValue) === Math.sign(x);\r\n                            // const isFrontValue = Math.sign(xZeroValue) === Math.sign(x);\r\n\r\n                            if (isFront && !isFrontValue) { continue; }\r\n                            if (!isFront && isFrontValue) { continue; }\r\n\r\n                            // if (isFront && isFrontX) { continue; }\r\n                            // if (!isFront && (isFrontOnLeft && x > 0 || !isFrontOnLeft && x < 0)) { continue; }\r\n                            // if (!isFront && value !== 0) { continue; }\r\n\r\n                            const colorKey = index + 1;\r\n\r\n                            // const alphaShift = 0.5 + 0.5 * (x / clockRadius) * (isFrontOnLeft ? -1 : 1);\r\n                            // const alphaShift = 1;\r\n                            const alphaShift = isFront ? 1 : 0.25;\r\n                            const lowAlpha = Math.ceil(units < 100 ? 100 : 25);\r\n\r\n                            s.noFill();\r\n                            s.stroke(s.color((cr * colorKey) % 255, (cg * colorKey) % 255, (cb * colorKey) % 255, Math.ceil((value === 0 ? 255 : lowAlpha) * alphaShift)));\r\n                            s.strokeWeight(2);\r\n                            s.line(x * (1 - 0.05 * Math.abs(zRotation)), y * 0.95, x, y);\r\n\r\n                            if (i === 0) {\r\n                                s.stroke(s.color((cr * colorKey) % 255, (cg * colorKey) % 255, (cb * colorKey) % 255, value === 0 ? 255 : 50));\r\n                                s.line(0, 0, x, y);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                };\r\n\r\n                s.translate(175, 175);\r\n\r\n                const defaultDelta = ((new Date(`2021-01-21 21:21:21.212Z`)).getTime() - Date.now());\r\n                // const defaultDelta = ((new Date(`2022-01-21 21:21:21.212Z`)).getTime() - Date.now());\r\n                // const defaultDelta = ((new Date(`2000-01-01 00:00:00.000Z`)).getTime() - Date.now());\r\n                // const defaultDelta = 0;\r\n\r\n                const tokenTimeDeltaSecs = tokenData?.timeDeltaSecs;\r\n                const delta = tokenTimeDeltaSecs != null ? tokenTimeDeltaSecs * 1000 : defaultDelta;\r\n                // console.log(`delta`, { delta, defaultDelta, tokenId });\r\n\r\n                const e = {\r\n                    year: Math.floor(delta / (1000 * 60 * 60 * 24 * 365)),\r\n                    month: Math.floor(delta / (1000 * 60 * 60 * 24 * 31) % 12),\r\n                    day: Math.floor(delta / (1000 * 60 * 60 * 24) % 31),\r\n                    hour: Math.floor(delta / (1000 * 60 * 60) % 24),\r\n                    minute: Math.floor(delta / (1000 * 60) % 60),\r\n                    second: Math.floor(delta / (1000) % 60),\r\n                    // ms: delta % 1000,\r\n                };\r\n                const isBefore = true;\r\n\r\n                // tick = 0;\r\n                for (let iTick = 0; iTick < 10; iTick++) {\r\n                    drawClock(0, 140, 100, e.year);\r\n                    drawClock(1, 120, 12, e.month);\r\n                    drawClock(2, 100, 31, e.day);\r\n                    drawClock(3, 80, 60, e.hour);\r\n                    drawClock(4, 60, 60, e.minute);\r\n                    drawClock(5, 40, 60, e.second);\r\n                    // drawClock(6, 20, 1000, e.ms);\r\n\r\n                    s.background(s.color(0, 0, 0, 5));\r\n                    tick++;\r\n                }\r\n\r\n                s.translate(-175, -175);\r\n\r\n\r\n                const drawText = () => {\r\n                    s.textSize(20);\r\n                    s.noStroke();\r\n                    s.textFont(`monospace`);\r\n\r\n                    const pad = (value: number, digits: number) => (`${value}`).padStart(digits, `0`);\r\n\r\n                    s.fill(s.color(255, 255, 255));\r\n                    s.text(`1/21/21 21:21:21 GST`, 60, 20);\r\n\r\n                    s.fill(!isBefore ? s.color(0, 255, 0) : s.color(255, 0, 0));\r\n                    s.text(`${isBefore ? `-` : `+`} ${pad(e.year, 2)}y ${pad(e.month, 2)}m ${pad(e.day, 2)}d ${pad(e.hour, 2)}:${pad(e.minute, 2)}:${pad(e.second, 2)}`, 50, 340);\r\n                };\r\n\r\n                // drawText();\r\n\r\n                tick++;\r\n            };\r\n        }, hostElement);\r\n    },\r\n};\r\n"],"sourceRoot":""}