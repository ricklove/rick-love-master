{"version":3,"sources":["webpack:///D:/Projects/rick-love-master/code/art/artwork/puzzle/art-puzzle-01.ts"],"names":["art_puzzle01","key","title","description","artist","getTokenDescription","tokenId","renderArt","hostElement","oppositeDirection","dir","state","board","boardVisits","moveSequence","player","moveIndex","gameOverTime","calculateNextPos","posRaw","pos","y","x","p5","s","setup","createCanvas","background","random","createRandomGenerator","exit","renderSeed","item","Math","floor","renderPos","push","randomMove","direction","r","distance","gridSize","wallColorCount","wallColors","Array","map","getNextWallRandomSeed","lastReverseMove","calculatePlayerReverseMove","reverseMove","d","lastPos","nextPos","itemAtPos","find","itemAtNextPos","m","endPosition","actualDistance","startPosition","i","actualMove","length","unshift","p","console","log","actualReverseMove","isVisited","b","getRenderPosition","forEach","drawPuzzleItem","a","c","cr","cg","cb","ca","fill","stroke","strokeWeight","gameWon","targetRenderPos","aOffset","tick","tOffset","abs","sin","angle","trans","translate","rotate","rect","itemSize","spiralRadius","iOffset","cos","PI","mod","circle","draw","filter","activeMove","pPos","tPos","undefined","wallPos","wall","slice","timeSinceGameOver","Date","now","noStroke","keyPressed","keyCode","UP_ARROW","LEFT_ARROW","DOWN_ARROW","RIGHT_ARROW","getKeyDirection","nextMove"],"mappings":"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","file":"27-46a628339871bb21a3c6.js","sourcesContent":["/* eslint-disable new-cap */\r\n/* eslint-disable no-new */\r\nimport p5 from 'p5';\r\nimport { ArtWork } from '../../artwork-type';\r\nimport { createRandomGenerator } from '../../rando';\r\n\r\n\r\nconst parseTokenId_puzzle01 = (tokenId: string) => { return tokenId; };\r\n\r\nexport const art_puzzle01: ArtWork = {\r\n    key: `puzzle-01`,\r\n    title: `Puzzle 01`,\r\n    description: `Solve the puzzle and unlock the final art.\r\nDirections: Use arrow keys to move the circle towards the exit`,\r\n    artist: `Rick Love`,\r\n    getTokenDescription: (tokenId: string) => {\r\n        return null;\r\n    },\r\n    renderArt: (hostElement: HTMLElement, tokenId: string) => {\r\n        // const { a, b, c } = { a: 57, b: 23, c: 15 };\r\n\r\n\r\n        const tokenData = parseTokenId_puzzle01(tokenId);\r\n\r\n        type Vector2 = { x: number, y: number };\r\n\r\n        type BoardItem = {\r\n            /** Seed for the render math */\r\n            renderSeed: string;\r\n            item: 'player' | 'exit' | 'entrance' | 'wall' | 'wall-broken';\r\n            pos: Vector2;\r\n\r\n            renderPos?: Vector2;\r\n            targetRenderPos?: Vector2;\r\n            activeMove?: ActualMove;\r\n        };\r\n        type MoveDirection = 'up' | 'down' | 'left' | 'right';\r\n        const oppositeDirection = (dir: MoveDirection): MoveDirection => {\r\n            switch (dir) {\r\n            case `up`: return `down`;\r\n            case `down`: return `up`;\r\n            case `left`: return `right`;\r\n            case `right`: return `left`;\r\n            default: return `up`;\r\n            }\r\n        };\r\n        type Move = {\r\n            direction: MoveDirection;\r\n            distance: number;\r\n        };\r\n        type ActualMove = {\r\n            direction: MoveDirection;\r\n            distance: number;\r\n            startPosition: Vector2;\r\n            endPosition: Vector2;\r\n        };\r\n        const state = {\r\n            board: [] as BoardItem[],\r\n            boardVisits: [] as { pos: Vector2 }[],\r\n            moveSequence: [] as ActualMove[],\r\n            player: {} as BoardItem,\r\n            moveIndex: 0,\r\n            gameOverTime: 0,\r\n        };\r\n\r\n        const canvasSize = 350;\r\n        const gridSize = 16;\r\n        const itemSize = 20;\r\n        const gridAreaOffset = 15;\r\n        const maxMoveCount = 20;\r\n\r\n        const calculateNextPos = (posRaw: Vector2, dir: MoveDirection): Vector2 => {\r\n            const pos = { ...posRaw };\r\n            if (dir === `up`) { pos.y--; }\r\n            if (dir === `down`) { pos.y++; }\r\n            if (dir === `left`) { pos.x--; }\r\n            if (dir === `right`) { pos.x++; }\r\n            return pos;\r\n        };\r\n\r\n        return new p5((s: p5) => {\r\n            s.setup = () => {\r\n                s.createCanvas(canvasSize, canvasSize);\r\n                s.background(0);\r\n                // s.colorMode(s.HSB);\r\n\r\n                // Create board out of backwards generation of correct moves\r\n                const { random } = createRandomGenerator(tokenId);\r\n\r\n                const { board, boardVisits } = state;\r\n                const exit: BoardItem = {\r\n                    renderSeed: `${random()}`,\r\n                    item: `exit`,\r\n                    pos: {\r\n                        x: Math.floor(1 + (gridSize - 2) * random()),\r\n                        y: Math.floor(1 + (gridSize - 2) * random()),\r\n                    },\r\n                };\r\n\r\n                state.player = {\r\n                    renderSeed: `${random()}`,\r\n                    item: `player`,\r\n                    pos: { ...exit.pos },\r\n                    renderPos: { x: 0, y: 0 },\r\n                };\r\n                const { player } = state;\r\n\r\n                board.push(exit);\r\n                // board.push(player);\r\n\r\n                // // Crete outer wall\r\n                // for (let i = 0; i < gridSize; i++) {\r\n                //     board.push({ renderSeed: `${random()}`, item: `wall`, pos: { x: i, y: 0 } });\r\n                //     board.push({ renderSeed: `${random()}`, item: `wall`, pos: { x: i, y: gridSize - 1 } });\r\n                //     board.push({ renderSeed: `${random()}`, item: `wall`, pos: { x: 0, y: i } });\r\n                //     board.push({ renderSeed: `${random()}`, item: `wall`, pos: { x: gridSize - 1, y: i } });\r\n                // }\r\n\r\n                const randomMoveDirection = (): MoveDirection => {\r\n                    const r = random();\r\n                    if (r > 0.75) { return `up`; }\r\n                    if (r > 0.5) { return `down`; }\r\n                    if (r > 0.25) { return `left`; }\r\n                    return `right`;\r\n                };\r\n                const randomMove = (): Move => {\r\n                    return {\r\n                        direction: randomMoveDirection(),\r\n                        distance: Math.floor(0 + gridSize * 0.75 * random()),\r\n                    };\r\n                };\r\n\r\n                const wallColorMaxCount = 16;\r\n                const wallColorCount = 4 + Math.floor(random() * (wallColorMaxCount - 4));\r\n                const wallColors = [...new Array(wallColorCount)].map(x => `${random()}`);\r\n                const getNextWallRandomSeed = () => {\r\n                    return wallColors[Math.floor(random() * wallColorCount)];\r\n                };\r\n\r\n                // Reversed moves to generate board\r\n                let lastReverseMove = {\r\n                    distance: 0,\r\n                    direction: `unknown`,\r\n                } as unknown as Move;\r\n\r\n                const calculatePlayerReverseMove = (reverseMove: Move): null | ActualMove => {\r\n                    let d = reverseMove.distance;\r\n                    let lastPos = { ...player.pos };\r\n\r\n                    const dir = reverseMove.direction;\r\n                    while (d > 0) {\r\n                        const pos = calculateNextPos(lastPos, dir);\r\n                        const nextPos = calculateNextPos(lastPos, dir);\r\n\r\n                        // Past edge - fail\r\n                        if (pos.x <= 0 || pos.x >= gridSize - 1\r\n                            || pos.y <= 0 || pos.y >= gridSize - 1) { return null; }\r\n\r\n                        // Hit existing wall - fail\r\n                        const itemAtPos = board.find(x => x.item !== `player` && x.pos.x === pos.x && x.pos.y === pos.y);\r\n                        if (itemAtPos?.item === `wall`) { return null; }\r\n\r\n                        // Already next wall - fail\r\n                        const itemAtNextPos = board.find(x => x.item !== `player` && x.pos.x === nextPos.x && x.pos.y === nextPos.y);\r\n                        if (itemAtNextPos?.item === `wall`) { return null; }\r\n\r\n                        d--;\r\n                        lastPos = { ...pos };\r\n                    }\r\n\r\n                    // If in line with any existing endmove, reject\r\n                    const inLineWithLastPos = state.moveSequence.find(m => m.endPosition.x === lastPos.x || m.endPosition.y === lastPos.y);\r\n                    if (inLineWithLastPos) { return null; }\r\n\r\n                    const actualDistance = reverseMove.distance - d;\r\n                    return {\r\n                        direction: oppositeDirection(reverseMove.direction),\r\n                        distance: actualDistance,\r\n                        endPosition: { ...player.pos },\r\n                        startPosition: lastPos,\r\n                    };\r\n                };\r\n\r\n                // Add outer wall\r\n                for (let i = 0; i < gridSize; i++) {\r\n                    board.push({ renderSeed: getNextWallRandomSeed(), item: `wall`, pos: { x: i, y: 0 } });\r\n                    board.push({ renderSeed: getNextWallRandomSeed(), item: `wall`, pos: { x: i, y: gridSize - 1 } });\r\n                    board.push({ renderSeed: getNextWallRandomSeed(), item: `wall`, pos: { x: 0, y: i } });\r\n                    board.push({ renderSeed: getNextWallRandomSeed(), item: `wall`, pos: { x: gridSize - 1, y: i } });\r\n                }\r\n\r\n                // Add game walls\r\n                for (let i = 0; i < maxMoveCount; i++) {\r\n\r\n                    // Reverse Move player\r\n                    let reverseMove = randomMove();\r\n                    while (reverseMove.direction === lastReverseMove.direction\r\n                        || reverseMove.direction === oppositeDirection(lastReverseMove.direction)) {\r\n                        reverseMove = randomMove();\r\n                    }\r\n\r\n                    // Calculate reverse move\r\n                    const actualMove = calculatePlayerReverseMove(reverseMove);\r\n                    if (!actualMove || actualMove.distance <= 0) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Add wall which would have stopped the player (having made this move forward)\r\n                    if (state.moveSequence.length > 0) {\r\n                        const nextPos = calculateNextPos(player.pos, oppositeDirection(reverseMove.direction));\r\n                        board.push({\r\n                            item: `wall`,\r\n                            pos: nextPos,\r\n                            renderSeed: getNextWallRandomSeed(),\r\n                        });\r\n                    }\r\n\r\n                    // Move player\r\n                    player.pos = actualMove.startPosition;\r\n                    state.moveSequence.unshift(actualMove);\r\n                    lastReverseMove = actualMove;\r\n\r\n                    // Add board visits\r\n                    let p = actualMove.startPosition;\r\n                    state.boardVisits.push({ pos: { ...p } });\r\n                    while (p.x !== actualMove.endPosition.x\r\n                        || p.y !== actualMove.endPosition.y) {\r\n                        p = calculateNextPos(p, actualMove.direction);\r\n                        state.boardVisits.push({ pos: { ...p } });\r\n                    }\r\n\r\n                    console.log(`boardVisits`, { actualReverseMove: actualMove, boardVisits: [...state.boardVisits] });\r\n                }\r\n\r\n                // Add random walls\r\n                for (let x = 0; x < gridSize; x++) {\r\n                    for (let y = 0; y < gridSize; y++) {\r\n                        const isVisited = !!boardVisits.find(b => b.pos.x === x && b.pos.y === y);\r\n                        const item = !!board.find(b => b.pos.x === x && b.pos.y === y);\r\n\r\n                        if (isVisited || item) { continue; }\r\n\r\n                        if (random() > 0.75) {\r\n                            board.push({\r\n                                item: `wall`,\r\n                                pos: { x, y },\r\n                                renderSeed: getNextWallRandomSeed(),\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                player.renderPos = getRenderPosition(player.pos);\r\n                state.board.forEach(x => drawPuzzleItem(x));\r\n            };\r\n\r\n            const getRenderPosition = (p: Vector2) => {\r\n                const x = gridAreaOffset + p.x * itemSize;\r\n                const y = gridAreaOffset + p.y * itemSize;\r\n                return { x, y };\r\n            };\r\n\r\n            const drawPuzzleItem = (item: typeof state.board[0]) => {\r\n                const { random } = createRandomGenerator(item.renderSeed);\r\n                const { a, b, c } = { a: 1 + Math.floor(57 * random()), b: 1 + Math.floor(213 * random()), c: 1 + Math.floor(115 * random()) };\r\n                const { cr, cg, cb, ca } = { cr: Math.floor(25 + 230 * random()), cg: Math.floor(25 + 230 * random()), cb: Math.floor(25 + 230 * random()), ca: Math.floor(25 + 125 * random()) };\r\n\r\n                const { x, y } = item.renderPos ?? getRenderPosition(item.pos);\r\n                s.fill(cr, cg, cb, ca);\r\n                s.stroke(cr, cg, cb, 255);\r\n                s.strokeWeight(1);\r\n\r\n                const gameWon = state.moveIndex >= state.moveSequence.length && !state.player.targetRenderPos;\r\n\r\n                const aOffset = tick / 100;\r\n                const tOffset = Math.abs(Math.floor(Math.sin((tick + a * c) / 1000) * canvasSize));\r\n                const alphaCycle = 100;\r\n\r\n                if (item.item === `player`) {\r\n                    if (gameWon) {\r\n                        s.stroke(0, 0, 0, 10);\r\n\r\n                        let mod = tick;\r\n                        for (let i = 0; i < 16; i++) {\r\n                            s.fill(cr, cg, (cb + i * c) % 255, Math.floor(Math.sin((tick + a * c) / alphaCycle) * 25 + 35));\r\n\r\n                            const j = 0;\r\n                            s.circle(200 - a / 2 + j % a, 200 - b / 2 + j % b, 270 - (i * 5) % c);\r\n                            s.translate(tOffset, tOffset);\r\n                            // s.rotate((a + b + c + tick * 0.001) % 2);\r\n                            s.rotate(((a + b + c + mod) * 0.001));\r\n                            s.translate(-tOffset, -tOffset);\r\n                            mod++;\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    s.fill(cr, cg, cb, 30);\r\n                    const circleCount = 4;\r\n                    const spiralRadius = 0.01 * (4 + state.moveSequence.length - state.moveIndex);\r\n                    // const spiralRadius = 0.1;\r\n                    for (let i = 0; i < circleCount; i++) {\r\n                        s.stroke(cr, cg, cb, Math.floor(255 * (i + 1) / (circleCount + 1)));\r\n\r\n                        s.circle(x + itemSize * (0.5 + spiralRadius * Math.cos(2 * Math.PI * (i / circleCount + tick / 100))), y + itemSize * (0.5 + spiralRadius * Math.sin(2 * Math.PI * (i / circleCount + tick / 100))), itemSize);\r\n                    }\r\n\r\n                    // s.circle(x + 0.5 * itemSize, y + 0.5 * itemSize, itemSize);\r\n                    return;\r\n                }\r\n\r\n                if (item.item === `exit`) {\r\n                    if (gameWon) {\r\n                        s.fill(cr, cg, cb, Math.floor(Math.sin((tick + a * c) / alphaCycle) * 25 + 35));\r\n                        s.stroke(0, 0, 0, 10);\r\n\r\n                        let angle = a;\r\n                        let trans = c;\r\n                        for (let i = 0; i < 32; i++) {\r\n\r\n                            // s.rect(x + itemSize * 0.25, y + itemSize * 0.25, itemSize * 0.5, itemSize * 0.5);\r\n                            s.translate(trans, trans);\r\n                            s.rotate(angle + aOffset);\r\n                            s.rect(x + itemSize * 0.25, y + itemSize * 0.25, c * x, c * y);\r\n                            s.rotate(-angle - aOffset);\r\n                            s.translate(-trans, -trans);\r\n                            angle += b;\r\n                            trans += c;\r\n                            trans %= 125;\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    // s.fill(cr, cg, cb, 200);\r\n                    s.fill(255, 255, 255);\r\n                    s.rect(x, y, itemSize, itemSize);\r\n                    s.fill(0, 0, 0);\r\n                    s.rect(x + itemSize * 0.25, y + itemSize * 0.25, itemSize * 0.5, itemSize * 0.5);\r\n                    return;\r\n                }\r\n\r\n                if (item.item === `wall-broken`) {\r\n                    if (!gameWon) { return; }\r\n\r\n                    s.fill(cr, cg, cb, Math.floor(Math.sin((tick + a * c) / alphaCycle) * 25 + 25));\r\n                    s.stroke(0, 0, 0, 10);\r\n\r\n                    let angle = a;\r\n                    const trans = c % (canvasSize * 0.5);\r\n                    for (let i = 0; i < 8; i++) {\r\n\r\n                        s.translate(-trans, -trans);\r\n                        s.rotate(angle + aOffset);\r\n                        s.rect(x, y, itemSize * x, itemSize * y);\r\n                        s.rotate(-angle - aOffset);\r\n                        s.translate(trans, trans);\r\n                        angle += b;\r\n                        // trans += c;\r\n                        // trans %= 3;\r\n                    }\r\n                    return;\r\n\r\n                    // s.rect(x + itemSize * 0.25, y + itemSize * 0.25, itemSize * 0.5, itemSize * 0.5);\r\n                    // s.rect(x, y, itemSize * x, itemSize * y);\r\n                    // return;\r\n                }\r\n\r\n                if (gameWon) {\r\n                    return;\r\n                    // s.fill(cr, cg, cb, Math.floor(Math.sin((tick + a * c) / alphaCycle) * 25 + 25));\r\n                    // s.rect(x, y, itemSize, itemSize);\r\n                    // return;\r\n                }\r\n                // s.rect(x, y, itemSize, itemSize);\r\n\r\n                s.fill(cr, cg, cb, 5);\r\n                const circleCount = 4;\r\n                const spiralRadius = 0.015 * (4 + state.moveSequence.length - state.moveIndex);\r\n                const iOffset = random();\r\n                for (let i = 0; i < circleCount; i++) {\r\n                    s.stroke(cr, cg, cb, Math.floor(255 * (i + 1) / (circleCount + 1)));\r\n                    s.rect(x + itemSize * (0 + spiralRadius * Math.cos(2 * Math.PI * ((iOffset + i) / circleCount + tick / 100))), y + itemSize * (0 + spiralRadius * Math.sin(2 * Math.PI * ((iOffset + i) / circleCount + tick / 100))), itemSize, itemSize);\r\n                }\r\n            };\r\n\r\n            let tick = 0;\r\n            s.draw = () => {\r\n                s.background(0);\r\n                // s.background(0, 0, 0, 5);\r\n\r\n                const drawMoveHistory = (m: typeof state.moveSequence[0]) => {\r\n                    s.noFill();\r\n                    s.stroke(255, 255, 255, 100);\r\n\r\n                    const x1 = gridAreaOffset + m.startPosition.x * itemSize + itemSize * 0.5;\r\n                    const y1 = gridAreaOffset + m.startPosition.y * itemSize + itemSize * 0.5;\r\n                    const x2 = gridAreaOffset + m.endPosition.x * itemSize + itemSize * 0.5;\r\n                    const y2 = gridAreaOffset + m.endPosition.y * itemSize + itemSize * 0.5;\r\n                    s.line(x1, y1, x2, y2);\r\n                    s.line(x1 + itemSize * 0.25, y1 + itemSize * 0.25, x2, y2);\r\n\r\n                    // s.text(`${i}`, x1,y1);\r\n                };\r\n\r\n                // state.board.forEach(x => drawPuzzleItem(x));\r\n                state.board.filter(x => x.item === `wall-broken`).forEach(x => drawPuzzleItem(x));\r\n                state.board.filter(x => x.item !== `wall-broken`).forEach(x => drawPuzzleItem(x));\r\n\r\n                drawPuzzleItem(state.player);\r\n\r\n                // Animate\r\n                if (state.player.activeMove && state.player.renderPos && state.player.targetRenderPos) {\r\n                    // state.player.renderPos = {\r\n                    //     x: 0.9 * state.player.renderPos.x + 0.1 * state.player.targetRenderPos.x,\r\n                    //     y: 0.9 * state.player.renderPos.y + 0.1 * state.player.targetRenderPos.y,\r\n                    // };\r\n\r\n                    const speed = 3;\r\n                    for (let i = 0; i < speed; i++) {\r\n                        state.player.renderPos = calculateNextPos(state.player.renderPos, state.player.activeMove.direction);\r\n\r\n                        const dist = Math.abs(state.player.renderPos.x - state.player.targetRenderPos.x)\r\n                            + Math.abs(state.player.renderPos.y - state.player.targetRenderPos.y);\r\n                        if (dist < 1) {\r\n                            state.player.renderPos = state.player.targetRenderPos;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // If player is done animating destroy wall\r\n                const { activeMove } = state.player;\r\n\r\n                const pPos = state.player.renderPos;\r\n                const tPos = state.player.targetRenderPos;\r\n                if (activeMove && pPos && tPos && pPos.x === tPos.x && pPos.y === tPos.y) {\r\n                    console.log(`Reached`, { activeMove, pPos, tPos });\r\n                    state.player.targetRenderPos = undefined;\r\n\r\n                    // Break any walls that have been reached\r\n                    for (const m of state.moveSequence.slice(0, state.moveIndex)) {\r\n                        const wallPos = calculateNextPos(m.endPosition, m.direction);\r\n                        const wall = state.board.find(x => x.pos.x === wallPos.x && x.pos.y === wallPos.y);\r\n                        if (!wall) { continue; }\r\n\r\n                        wall.item = `wall-broken`;\r\n                    }\r\n                }\r\n\r\n                const GAME_OVER_FADE_TIME = 3000;\r\n                const timeSinceGameOver = Date.now() - state.gameOverTime;\r\n                if (timeSinceGameOver < GAME_OVER_FADE_TIME){\r\n                    console.log(`Game over Fade`, { gameOverTime: state.gameOverTime, timeSinceGameOver });\r\n                    s.fill(0, 0, 0, 255 * (GAME_OVER_FADE_TIME - timeSinceGameOver) / GAME_OVER_FADE_TIME);\r\n                    s.noStroke();\r\n                    s.rect(0, 0, canvasSize, canvasSize);\r\n                }\r\n\r\n                // Debug\r\n                //  state.moveSequence.forEach(x => drawMoveHistory(x));\r\n                tick++;\r\n            };\r\n\r\n            s.keyPressed = () => {\r\n                const { key, keyCode } = s;\r\n\r\n                const getKeyDirection = (): null | MoveDirection => {\r\n                    switch (key) {\r\n                    case `w`: return `up`;\r\n                    case `a`: return `left`;\r\n                    case `s`: return `down`;\r\n                    case `d`: return `right`;\r\n                    default: break;\r\n                    }\r\n                    switch (keyCode) {\r\n                    case s.UP_ARROW: return `up`;\r\n                    case s.LEFT_ARROW: return `left`;\r\n                    case s.DOWN_ARROW: return `down`;\r\n                    case s.RIGHT_ARROW: return `right`;\r\n                    default: return null;\r\n                    }\r\n                };\r\n\r\n                const d = getKeyDirection();\r\n                if (!d) { return; }\r\n\r\n                // Move the player\r\n                const nextMove = state.moveSequence[state.moveIndex];\r\n                if (!nextMove) { return; }\r\n\r\n                if (nextMove.direction !== d) {\r\n                    // Reset game on bad move\r\n                    state.gameOverTime = Date.now();\r\n                    state.moveIndex = 0;\r\n                    state.player.activeMove = undefined;\r\n                    state.player.renderPos = undefined;\r\n                    state.player.targetRenderPos = undefined;\r\n                    state.board.filter(x => x.item === `wall-broken`).forEach(x => { x.item = `wall`; });\r\n                    return;\r\n                }\r\n\r\n                state.player.activeMove = nextMove;\r\n                state.player.renderPos = getRenderPosition(nextMove.startPosition);\r\n                state.player.targetRenderPos = getRenderPosition(nextMove.endPosition);\r\n                state.moveIndex++;\r\n            };\r\n        }, hostElement);\r\n    },\r\n};\r\n"],"sourceRoot":""}