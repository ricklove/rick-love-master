{"version":3,"sources":["webpack:///D:/Projects/rick-love-master/code/art/artwork/flying-colors/flying-colors.tsx"],"names":["path","art_flyingColors","key","title","description","artist","getTokenDescription","tokenId","renderArt","hostElement","hash","seed","random","createRandomGenerator","size","window","innerWidth","innerHeight","lastTimeMs","shaderInstance","p5","s","preload","loadShader","setup","createCanvas","WEBGL","noStroke","draw","millis","setUniform","mouseX","map","mouseY","shader","rect"],"mappings":"wHAAA,6FAMMA,EAAO,mDAEAC,EAA4B,CACrCC,IAAK,gBACLC,MAAO,gBACPC,YAAa,eACbC,OAAQ,YACRC,oBAAqB,SAACC,GAClB,OAAO,MAMXC,UAAW,SAACC,EAA0BC,QAA8B,IAA9BA,MAA8B,wBAI1DC,GAAOC,EADMC,YAAsBH,GAAjCE,UASFE,EAAOC,OAAOC,WAFA,KAE4BD,OAAOE,YAFnC,QACD,IAOfC,EAAa,EAIbC,EAAmC,KAEvC,OAAO,IAAIC,KAAG,SAACC,GACXA,EAAEC,QAAU,WACRH,EAAiBE,EAAEE,WAAcvB,EAAhB,QAAgCA,EAAhC,UAErBqB,EAAEG,MAAQ,WACNH,EAAEI,aAAaX,EAAMA,EAAMO,EAAEK,OAC7BL,EAAEM,YAENN,EAAEO,KAAO,WACL,GAAKT,EAAL,CAGiCE,EAAEQ,SACnCX,EAAaG,EAAEQ,SAiBfV,EAAeW,WAAf,eAA0C,CAAChB,EAAMA,IACjDK,EAAeW,WAAf,SAAoCZ,EAAa,KACjDC,EAAeW,WAAf,UAAqC,CAACT,EAAEU,OAAQV,EAAEW,IAAIX,EAAEY,OAAQ,EAAGnB,EAAMA,EAAM,KAC/EK,EAAeW,WAAf,SAAoCnB,GAGpCU,EAAEa,OAAOf,GAGTE,EAAEc,KAAK,EAAG,EAAGrB,EAAMA,OAExBL","file":"22-238df889f70718221dc0.js","sourcesContent":["/* eslint-disable new-cap */\r\n/* eslint-disable no-new */\r\nimport p5 from 'p5';\r\nimport { createRandomGenerator } from '../../rando';\r\nimport { ArtWork } from '../../artwork-type';\r\n\r\nconst path = `/content/art/artwork/flying-colors/flying-colors`;\r\n\r\nexport const art_flyingColors: ArtWork = {\r\n    key: `flying-colors`,\r\n    title: `Flying Colors`,\r\n    description: `Mmmm, bright`,\r\n    artist: `Rick Love`,\r\n    getTokenDescription: (tokenId: string) => {\r\n        return null;\r\n    },\r\n    // openSea: {\r\n    //     tokenAddress: `0x495f947276749ce646f68ac8c248420045cb7b5e`,\r\n    //     tokenId: `91242641486941084018191434774360347389366801368112854311223385694785434025985`,\r\n    // },\r\n    renderArt: (hostElement: HTMLElement, hash = `This is my hash!`) => {\r\n        // const { a, b, c } = { a: 57, b: 23, c: 15 };\r\n\r\n        const { random } = createRandomGenerator(hash);\r\n        const seed = random();\r\n\r\n\r\n        // const { a, b, c } = { a: 1 + Math.floor(57 * random()), b: 1 + Math.floor(213 * random()), c: 1 + Math.floor(115 * random()) };\r\n        // const { cr, cg, cb, ca } = { cr: Math.floor(25 + 230 * random()), cg: Math.floor(25 + 230 * random()), cb: Math.floor(25 + 230 * random()), ca: Math.floor(25 + 25 * random()) };\r\n\r\n        const TARGET_SIZE = 600;\r\n        const SMALL_SIZE = 300;\r\n        const size = window.innerWidth > TARGET_SIZE && window.innerHeight > TARGET_SIZE ? TARGET_SIZE : SMALL_SIZE;\r\n        // const h = 200;\r\n        // const scale = size / 400;\r\n        // const speed = 0.5;\r\n\r\n        // let tick = 0;\r\n        let lastTimeMs = 0;\r\n        const gameTimeMs = 0;\r\n        const lastTimeModifier = 1;\r\n\r\n        let shaderInstance: null | p5.Shader = null;\r\n\r\n        return new p5((s: p5) => {\r\n            s.preload = () => {\r\n                shaderInstance = s.loadShader(`${path}.vert`, `${path}.frag`);\r\n            };\r\n            s.setup = () => {\r\n                s.createCanvas(size, size, s.WEBGL);\r\n                s.noStroke();\r\n            };\r\n            s.draw = () => {\r\n                if (!shaderInstance) { return; }\r\n\r\n                // send resolution of sketch into shader\r\n                const deltaTimeMs = lastTimeMs - s.millis();\r\n                lastTimeMs = s.millis();\r\n\r\n                // const timeModifier = 0.7 * (0.5 + 0.7 * Math.cos(s.millis() / (5 * 1000)));\r\n                // const timeModifier01 = lastTimeModifier + 0.25 * (0.5 - Math.random());\r\n                // const timeModifier02 = Math.min(1, Math.max(0, timeModifier01));\r\n                // const dampen = Math.pow(Math.abs(timeModifier02 - 0.5) * 2, 5);\r\n                // const timeModifier = dampen * 0.5 + (1 - dampen) * timeModifier02;\r\n\r\n                // const timeModifier01 = lastTimeModifier + 0.25 * (0.5 - Math.random());\r\n                // const timeModifier02 = Math.min(1, Math.max(0, timeModifier01));\r\n\r\n                // lastTimeModifier = timeModifier;\r\n                // gameTimeMs += deltaTimeMs * timeModifier;\r\n\r\n\r\n                // console.log(`draw`, { lastTimeModifier, seed, mouse: s.mouseX, gameTimeMs });\r\n\r\n                shaderInstance.setUniform(`u_resolution`, [size, size]);\r\n                shaderInstance.setUniform(`u_time`, lastTimeMs / 1000);\r\n                shaderInstance.setUniform(`u_mouse`, [s.mouseX, s.map(s.mouseY, 0, size, size, 0)]);\r\n                shaderInstance.setUniform(`u_seed`, seed);\r\n\r\n                // shader() sets the active shader with our shader\r\n                s.shader(shaderInstance);\r\n\r\n                // rect gives us some geometry on the screen\r\n                s.rect(0, 0, size, size);\r\n            };\r\n        }, hostElement);\r\n    },\r\n};\r\n"],"sourceRoot":""}